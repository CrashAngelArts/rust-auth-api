[
  {
    "id": 1,
    "title": "C√≥digo √önico de Recupera√ß√£o",
    "description": "üîë\n   - Adicionar campos na tabela de usu√°rios para armazenar c√≥digo de recupera√ß√£o\n   - Implementar gera√ß√£o segura de c√≥digo √∫nico (alfanum√©rico)\n   - Implementar verifica√ß√£o e valida√ß√£o do c√≥digo\n   - Integrar no fluxo de reset de senha\n   - Implementar limpeza autom√°tica ap√≥s uso\n\n2. **An√°lise de Riscos na Autentica√ß√£o** üõ°Ô∏è\n   - **Detec√ß√£o de Localiza√ß√£o Suspeita**:",
    "priority": "alta",
    "category": "Geral",
    "code_example": "pub struct LocationRiskAnalyzer {\n         pub geo_database: GeoIpDatabase,\n         pub velocity_threshold_km_h: f64,\n         pub risk_threshold_distance_km: u32,\n     }\n     \n     impl LocationRiskAnalyzer {\n         pub fn analyze_login_attempt(\n             &self,\n             user_id: &str,\n             current_ip: &str,\n             previous_logins: &[LoginHistory]\n         ) -> LoginRiskAssessment {\n             // Implementa√ß√£o para detectar mudan√ßas geogr√°ficas suspeitas\n         }\n     }",
    "status": "pendente",
    "tags": [
      "geral",
      "jwt",
      "password",
      "auth",
      "user",
      "geolocation",
      "risk",
      "recovery"
    ],
    "context": "Geral"
  },
  {
    "id": 2,
    "title": "Gerenciamento de Sess√µes Aprimorado",
    "description": "üì±\n   - **Revoga√ß√£o de Sess√£o Individual**:",
    "priority": "m√©dia",
    "category": "Geral",
    "code_example": "pub async fn revoke_specific_session(\n         pool: &DbPool,\n         user_id: &str,\n         session_id: &str,\n     ) -> Result<bool, ApiError> {\n         // Implementa√ß√£o para revogar sess√£o espec√≠fica\n     }",
    "status": "pendente",
    "tags": [
      "geral",
      "session"
    ],
    "context": "Geral"
  },
  {
    "id": 3,
    "title": "Auditoria e Logs Aprimorados",
    "description": "üìä\n   - **Logs de A√ß√µes Cr√≠ticas**:",
    "priority": "m√©dia",
    "category": "Auditoria",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n     pub struct AuditLogEntry {\n         pub id: String,\n         pub user_id: Option<String>,\n         pub admin_id: Option<String>,\n         pub action: AuditAction,\n         pub resource_type: String,\n         pub resource_id: Option<String>,\n         pub timestamp: DateTime<Utc>,\n         pub ip_address: Option<String>,\n         pub user_agent: Option<String>,\n         pub details: Option<Value>,\n         pub status: AuditStatus,\n     }\n     \n     pub async fn log_critical_action(\n         pool: &DbPool,\n         entry: AuditLogEntry,\n     ) -> Result<(), ApiError> {\n         // Implementa√ß√£o para registrar a√ß√µes cr√≠ticas\n     }",
    "status": "pendente",
    "tags": [
      "auditoria",
      "log"
    ],
    "context": "Auditoria"
  },
  {
    "id": 4,
    "title": "WebAuthn/Passkeys",
    "description": "üîë\n   - Expandir a estrutura inicial j√° criada:",
    "priority": "baixa",
    "category": "Autentica√ß√£o",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n     pub struct WebAuthnCredential {\n         pub id: String,\n         pub user_id: String,\n         pub public_key: String,\n         pub attestation_type: String,\n         pub aaguid: String, // Authenticator Attestation GUID\n         pub credential_id: String,\n         pub counter: u32,\n         pub created_at: DateTime<Utc>,\n         pub last_used_at: Option<DateTime<Utc>>,\n         pub is_active: bool,\n     }\n     \n     pub async fn register_credential(\n         pool: &DbPool,\n         user_id: &str,\n         registration_options: &PublicKeyCredentialCreationOptions,\n         attestation_response: &AuthenticatorAttestationResponse,\n     ) -> Result<WebAuthnCredential, ApiError> {\n         // Implementa√ß√£o para registrar credencial\n     }\n     \n     pub async fn verify_assertion(\n         pool: &DbPool,\n         user_id: &str,\n         assertion_response: &AuthenticatorAssertionResponse,\n     ) -> Result<bool, ApiError> {\n         // Implementa√ß√£o para verificar autentica√ß√£o\n     }",
    "status": "pendente",
    "tags": [
      "autentica√ß√£o",
      "auth"
    ],
    "context": "Autentica√ß√£o"
  },
  {
    "id": 5,
    "title": "Sistema de Webhooks",
    "description": "üîÑ\n   - Expandir a estrutura b√°sica j√° criada:",
    "priority": "baixa",
    "category": "Integra√ß√£o",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n     pub struct WebhookSubscription {\n         pub id: String,\n         pub client_id: String,\n         pub event_types: Vec<String>,\n         pub url: String,\n         pub secret: String, // Para assinatura HMAC\n         pub is_active: bool,\n         pub created_at: DateTime<Utc>,\n         pub updated_at: DateTime<Utc>,\n         pub last_success: Option<DateTime<Utc>>,\n         pub failure_count: u32,\n     }\n     \n     pub async fn trigger_webhook(\n         pool: &DbPool,\n         event_type: &str,\n         payload: &Value,\n     ) -> Result<(), ApiError> {\n         // Implementa√ß√£o para disparar webhook\n     }\n     \n     pub async fn register_webhook(\n         pool: &DbPool,\n         subscription: WebhookSubscription,\n     ) -> Result<String, ApiError> {\n         // Implementa√ß√£o para registrar inscri√ß√£o\n     }",
    "status": "pendente",
    "tags": [
      "integra√ß√£o",
      "webhook"
    ],
    "context": "Integra√ß√£o"
  },
  {
    "id": 6,
    "title": "Implementar graceful shutdown",
    "description": "Adicionar tratamento para sinais SIGTERM e SIGINT para desligar o servidor de forma segura",
    "priority": "m√©dia",
    "category": "Main.rs",
    "code_example": "let (tx, rx) = tokio::sync::mpsc::channel(1);\n   ctrlc::set_handler(move || {\n       tx.try_send(()).ok();\n   }).expect(\"Error setting Ctrl-C handler\");",
    "status": "pendente",
    "tags": [
      "main.rs"
    ],
    "context": "Main.rs"
  },
  {
    "id": 7,
    "title": "Configura√ß√£o de TLS",
    "description": "Adicionar suporte a HTTPS em produ√ß√£o",
    "priority": "m√©dia",
    "category": "Main.rs",
    "code_example": ".bind_rustls(format!(\"{}:{}\", config.server.host, config.server.port), rustls_config)?",
    "status": "pendente",
    "tags": [
      "main.rs",
      "config"
    ],
    "context": "Main.rs"
  },
  {
    "id": 8,
    "title": "Limita√ß√£o de conex√µes",
    "description": "Configurar limites de conex√µes m√°ximas",
    "priority": "m√©dia",
    "category": "Main.rs",
    "code_example": "HttpServer::new(move || { ... })\n      .workers(config.server.workers)\n      .max_connections(config.server.max_connections)",
    "status": "pendente",
    "tags": [
      "main.rs",
      "config",
      "rate-limit"
    ],
    "context": "Main.rs"
  },
  {
    "id": 9,
    "title": "Telemetria",
    "description": "Integrar com algum sistema de monitoramento como Prometheus",
    "priority": "m√©dia",
    "category": "Main.rs",
    "code_example": ".app_data(web::Data::new(metrics_registry.clone()))\n   .route(\"/metrics\", web::get().to(metrics_handler))",
    "status": "pendente",
    "tags": [
      "main.rs",
      "log",
      "monitoring"
    ],
    "context": "Main.rs"
  },
  {
    "id": 10,
    "title": "Extra√ß√£o de configura√ß√µes",
    "description": "Extrair a configura√ß√£o do servidor HTTP para uma fun√ß√£o separada para melhorar a legibilidade.\n\n### `src/lib.rs`\n\n**An√°lise:**\n- ‚úÖ Exporta√ß√£o adequada de m√≥dulos\n- ‚úÖ C√≥digo limpo e organizado\n- ‚úÖ Coment√°rios √∫teis\n\n**Melhorias Sugeridas:**\n1. üìù **Adicionar documenta√ß√£o** - Incluir um coment√°rio principal explicando o prop√≥sito da biblioteca",
    "priority": "m√©dia",
    "category": "Main.rs",
    "code_example": "//! Rust Auth API - Uma biblioteca de autentica√ß√£o completa usando Actix-web e SQLite.\n   //! \n   //! Esta biblioteca oferece funcionalidades de autentica√ß√£o, autoriza√ß√£o e gerenciamento\n   //! de usu√°rios para aplica√ß√µes web seguras.",
    "status": "pendente",
    "tags": [
      "main.rs",
      "ui",
      "config",
      "risk"
    ],
    "context": "Main.rs"
  },
  {
    "id": 11,
    "title": "Adicionar metadados de crate",
    "description": "No Cargo.toml, adicionar:\n   ```toml\n   authors = [\"Seu Nome <seu.email@exemplo.com>\"]\n   repository = \"https://github.com/seu-usuario/rust-auth-api\"\n   documentation = \"https://docs.rs/rust-auth-api\"\n   readme = \"README.md\"\n   ```\n\n3. üìù **Adicionar testes de integra√ß√£o** - Criar uma pasta tests/ na raiz com testes de integra√ß√£o para API.\n\n4. üìù **Incluir vers√£o e registro** - Adicionar constantes de vers√£o para facilitar o rastreamento",
    "priority": "m√©dia",
    "category": "Lib.rs",
    "code_example": "pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n   pub const BUILD_TIME: &str = env!(\"BUILD_TIMESTAMP\"); // Requer script de build",
    "status": "pendente",
    "tags": [
      "lib.rs",
      "test",
      "api",
      "ui",
      "auth",
      "email",
      "rate-limit"
    ],
    "context": "Lib.rs"
  },
  {
    "id": 12,
    "title": "Valida√ß√£o de configura√ß√µes cr√≠ticas",
    "description": "Adicionar valida√ß√µes expl√≠citas para valores cr√≠ticos",
    "priority": "m√©dia",
    "category": "Config",
    "code_example": "fn validate_config(&self) -> Result<(), String> {\n       if self.jwt.secret.len() < 32 {\n           return Err(\"JWT secret muito curto, deve ter pelo menos 32 caracteres\".to_string());\n       }\n       // Mais valida√ß√µes...\n       Ok(())\n   }",
    "status": "pendente",
    "tags": [
      "config"
    ],
    "context": "Config"
  },
  {
    "id": 13,
    "title": "Suporte a arquivos de configura√ß√£o",
    "description": "Adicionar suporte para carregar configura√ß√µes de arquivos YAML/TOML/JSON al√©m de vari√°veis de ambiente",
    "priority": "m√©dia",
    "category": "Config",
    "code_example": "pub fn from_file(path: &str) -> Result<Self, ConfigError> {\n       let file = std::fs::File::open(path)?;\n       let config: Config = serde_yaml::from_reader(file)?;\n       Ok(config)\n   }",
    "status": "pendente",
    "tags": [
      "config",
      "ui"
    ],
    "context": "Config"
  },
  {
    "id": 14,
    "title": "Configura√ß√µes por ambiente",
    "description": "Implementar carregamento condicional baseado em ambiente",
    "priority": "m√©dia",
    "category": "Config",
    "code_example": "let env = std::env::var(\"ENVIRONMENT\").unwrap_or_else(|_| \"development\".to_string());\n   let config_path = format!(\"config/{}.yaml\", env);",
    "status": "pendente",
    "tags": [
      "config"
    ],
    "context": "Config"
  },
  {
    "id": 15,
    "title": "Mascaramento de segredos",
    "description": "Implementar mascaramento para logs de valores sens√≠veis",
    "priority": "m√©dia",
    "category": "Config",
    "code_example": "impl std::fmt::Display for JwtConfig {\n       fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n           write!(f, \"JwtConfig {{ secret: \\\"****\\\", expiration: {} }}\", self.expiration)\n       }\n   }",
    "status": "pendente",
    "tags": [
      "config",
      "log"
    ],
    "context": "Config"
  },
  {
    "id": 16,
    "title": "Cache de configura√ß√£o",
    "description": "Implementar cache para configura√ß√µes que s√£o acessadas frequentemente",
    "priority": "m√©dia",
    "category": "Config",
    "code_example": "pub fn get_instance() -> Arc<Config> {\n       static INSTANCE: OnceCell<Arc<Config>> = OnceCell::new();\n       INSTANCE.get_or_init(|| {\n           Arc::new(Config::from_env().expect(\"Failed to load config\"))\n       }).clone()\n   }",
    "status": "pendente",
    "tags": [
      "config",
      "cache"
    ],
    "context": "Config"
  },
  {
    "id": 17,
    "title": "Documenta√ß√£o detalhada",
    "description": "Adicionar documenta√ß√£o detalhada para cada campo de configura√ß√£o:\n   ```rust\n   /// Configura√ß√£o do servidor web\n   /// \n   /// # Campos\n   /// \n   /// * `host` - Endere√ßo IP para vincular o servidor HTTP\n   /// * `port` - Porta para vincular o servidor HTTP\n   /// * `workers` - N√∫mero de workers para processar requisi√ß√µes (padr√£o: n√∫cleos l√≥gicos)\n   #[derive(Debug, Deserialize, Clone)]\n   pub struct ServerConfig { /*...*/ }\n   ```\n\n### `src/errors/mod.rs`\n\n**An√°lise:**\n- ‚úÖ Uso adequado da biblioteca thiserror para defini√ß√£o de erros\n- ‚úÖ Boa estrutura de mapeamento de erros para respostas HTTP\n- ‚úÖ Implementa√ß√£o adequada de convers√£o de erros de bibliotecas externas\n- ‚úÖ Suporte a erros de valida√ß√£o com detalhes estruturados\n- ‚úÖ Logging adequado de erros\n\n**Melhorias Sugeridas:**\n1. üîí **Sanitiza√ß√£o de mensagens de erro** - Implementar sanitiza√ß√£o para n√£o expor detalhes sens√≠veis em ambientes de produ√ß√£o",
    "priority": "m√©dia",
    "category": "Config",
    "code_example": "fn sanitize_error_message(message: &str, is_production: bool) -> String {\n       if is_production && message.contains(\"senha\") {\n           return \"Erro interno durante processamento de credenciais\".to_string();\n       }\n       message.to_string()\n   }",
    "status": "pendente",
    "tags": [
      "config",
      "log",
      "ui",
      "risk"
    ],
    "context": "Config"
  },
  {
    "id": 18,
    "title": "C√≥digos de erro mais descritivos",
    "description": "Implementar c√≥digos de erro padronizados e mais espec√≠ficos",
    "priority": "m√©dia",
    "category": "Errors",
    "code_example": "pub enum ErrorCode {\n       AuthInvalidCredentials = 1001,\n       AuthTokenExpired = 1002,\n       AuthTokenInvalid = 1003,\n       ValidationFailure = 2001,\n       // etc.\n   }",
    "status": "pendente",
    "tags": [
      "errors"
    ],
    "context": "Errors"
  },
  {
    "id": 19,
    "title": "Internacionaliza√ß√£o de mensagens de erro",
    "description": "Adicionar suporte para mensagens de erro em m√∫ltiplos idiomas",
    "priority": "m√©dia",
    "category": "Errors",
    "code_example": "pub fn localized_message(&self, lang: &str) -> String {\n       let key = match self {\n           ApiError::AuthenticationError(_) => \"error.auth.failed\",\n           // etc.\n       };\n       i18n::translate(key, lang)\n   }",
    "status": "pendente",
    "tags": [
      "errors"
    ],
    "context": "Errors"
  },
  {
    "id": 20,
    "title": "Documenta√ß√£o de erros para API",
    "description": "Gerar documenta√ß√£o OpenAPI para os erros da API",
    "priority": "m√©dia",
    "category": "Errors",
    "code_example": "/// Erro retornado quando um usu√°rio n√£o est√° autorizado a acessar um recurso.\n   /// \n   /// Status: 403 Forbidden\n   #[derive(Error, Debug)]\n   #[error(\"Erro de autoriza√ß√£o: {0}\")]\n   pub struct AuthorizationError(pub String);",
    "status": "pendente",
    "tags": [
      "errors",
      "api"
    ],
    "context": "Errors"
  },
  {
    "id": 21,
    "title": "Unifica√ß√£o de erros duplicados",
    "description": "Remover redund√¢ncias como `BadRequestError`/`BadRequest` e `NotFoundError`/`NotFound`",
    "priority": "m√©dia",
    "category": "Errors",
    "code_example": "#[error(\"Requisi√ß√£o inv√°lida: {0}\")]\n   BadRequest(String),  // Manter apenas esta vers√£o",
    "status": "pendente",
    "tags": [
      "errors"
    ],
    "context": "Errors"
  },
  {
    "id": 22,
    "title": "Implementar recovery de panic",
    "description": "Adicionar middleware para capturar panics e convert√™-los em erros 500",
    "priority": "m√©dia",
    "category": "Errors",
    "code_example": "pub fn capture_panic(info: &PanicInfo) -> HttpResponse {\n       let error = ApiError::InternalServerError(\"Ocorreu um erro interno inesperado\".to_string());\n       error.error_response()\n   }",
    "status": "pendente",
    "tags": [
      "errors",
      "recovery"
    ],
    "context": "Errors"
  },
  {
    "id": 23,
    "title": "Parametriza√ß√£o de configura√ß√µes de pool",
    "description": "Tornar os par√¢metros do pool configur√°veis",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "let pool = Pool::builder()\n       .max_size(config.database.max_connections)\n       .min_idle(Some(config.database.min_connections))\n       .idle_timeout(Some(Duration::from_secs(config.database.idle_timeout)))\n       .build(manager)?;",
    "status": "pendente",
    "tags": [
      "db",
      "config"
    ],
    "context": "Db"
  },
  {
    "id": 24,
    "title": "Valida√ß√£o de integridade do banco",
    "description": "Adicionar uma verifica√ß√£o de integridade no startup",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "fn validate_db_integrity(conn: &Connection) -> Result<(), ApiError> {\n       let integrity_check: String = conn.query_row(\"PRAGMA integrity_check\", [], |row| row.get(0))?;\n       if integrity_check != \"ok\" {\n           return Err(ApiError::DatabaseError(format!(\"Falha na verifica√ß√£o de integridade: {}\", integrity_check)));\n       }\n       Ok(())\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 25,
    "title": "Logs de m√©tricas de pool",
    "description": "Adicionar logs peri√≥dicos de m√©tricas do pool",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "fn log_pool_metrics(pool: &DbPool) {\n       let state = pool.state();\n       info!(\"Pool DB: conex√µes={}, em_uso={}, idle={}\",\n             state.connections, state.in_use, state.idle);\n   }",
    "status": "pendente",
    "tags": [
      "db",
      "log"
    ],
    "context": "Db"
  },
  {
    "id": 26,
    "title": "Backup autom√°tico",
    "description": "Implementar um mecanismo de backup autom√°tico",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "fn backup_database(db_path: &str, backup_dir: &str) -> Result<(), ApiError> {\n       let timestamp = chrono::Utc::now().format(\"%Y%m%d_%H%M%S\");\n       let backup_path = format!(\"{}/backup_{}.db\", backup_dir, timestamp);\n       let conn = Connection::open(db_path)?;\n       let backup = Connection::open(&backup_path)?;\n       conn.backup(rusqlite::DatabaseName::Main, &backup, None)?;\n       Ok(())\n   }",
    "status": "pendente",
    "tags": [
      "db",
      "backup"
    ],
    "context": "Db"
  },
  {
    "id": 27,
    "title": "Roteamento de conex√µes",
    "description": "Implementar um roteador de conex√µes para separar leitura/escrita",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "pub enum DbAccessType {\n       ReadOnly,\n       ReadWrite,\n   }\n   \n   pub fn get_connection(pool: &DbPool, access_type: DbAccessType) -> Result<DbConnection, ApiError> {\n       let conn = pool.get()?;\n       match access_type {\n           DbAccessType::ReadOnly => {\n               conn.execute_batch(\"PRAGMA query_only = ON;\")?;\n           },\n           DbAccessType::ReadWrite => {},\n       }\n       Ok(conn)\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 28,
    "title": "Extens√µes de conex√£o",
    "description": "Adicionar uma extens√£o para encapsular opera√ß√µes comuns",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "pub trait ConnectionExt {\n       fn with_transaction<T, F>(&mut self, f: F) -> Result<T, ApiError>\n       where F: FnOnce(&rusqlite::Transaction<'_>) -> Result<T, ApiError>;\n   }\n   \n   impl ConnectionExt for rusqlite::Connection {\n       fn with_transaction<T, F>(&mut self, f: F) -> Result<T, ApiError>\n       where F: FnOnce(&rusqlite::Transaction<'_>) -> Result<T, ApiError> {\n           let tx = self.transaction()?;\n           let result = f(&tx);\n           match result {\n               Ok(value) => {\n                   tx.commit()?;\n                   Ok(value)\n               }\n               Err(e) => {\n                   tx.rollback()?;\n                   Err(e)\n               }\n           }\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 29,
    "title": "Rate Limiting por Endpoint",
    "description": "Implementar limita√ß√£o de taxa por endpoint sens√≠vel",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[middleware::rate_limit(per_second = 1, burst = 5)]\n   pub async fn change_password(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "api",
      "rate-limit"
    ],
    "context": "Controllers"
  },
  {
    "id": 30,
    "title": "Documenta√ß√£o OpenAPI",
    "description": "Adicionar anota√ß√µes OpenAPI para documenta√ß√£o autom√°tica",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "/// Registra um novo usu√°rio no sistema.\n   /// \n   /// Retorna os dados do usu√°rio criado, sem informa√ß√µes sens√≠veis.\n   #[openapi(\n   ///   path = \"/auth/register\",\n   ///   method = \"post\",\n   ///   tags = [\"auth\"],\n   ///   request_body = RegisterDto\n   /// )]\n   pub async fn register(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "api"
    ],
    "context": "Controllers"
  },
  {
    "id": 31,
    "title": "Aplica√ß√£o de pol√≠ticas de seguran√ßa",
    "description": "Implementar pol√≠ticas de seguran√ßa como CORS e CSP de forma configur√°vel",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn login(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n       let response = HttpResponse::Ok()\n           .insert_header((\"Content-Security-Policy\", config.security.csp_policy.clone()))\n           .json(ApiResponse::success_with_message(auth_response, \"Login realizado com sucesso\"));\n       Ok(response)\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa",
      "config"
    ],
    "context": "Controllers"
  },
  {
    "id": 32,
    "title": "Eventos de auditoria",
    "description": "Adicionar registro de eventos para a√ß√µes cr√≠ticas",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn delete_user(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n       audit_log::record(\n           &pool,\n           \"user.delete\",\n           &claims.sub,\n           AuditData::new()\n               .add(\"target_user_id\", &user_id)\n               .add(\"admin_action\", true)\n       ).await?;\n       // Resto da implementa√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "log",
      "webhook"
    ],
    "context": "Controllers"
  },
  {
    "id": 33,
    "title": "M√©tricas de uso",
    "description": "Adicionar instrumenta√ß√£o para m√©tricas",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn login(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n       metrics::increment_counter!(\"auth_login_total\");\n       metrics::histogram!(\"auth_login_duration_ms\", start.elapsed().as_millis() as f64);\n       // Resto da implementa√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 34,
    "title": "Refatora√ß√£o de valida√ß√µes de autoriza√ß√£o",
    "description": "Criar um helper para verifica√ß√µes comuns de autoriza√ß√£o",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "fn ensure_authorized(claims: &TokenClaims, user_id: &str, action: &str) -> Result<(), ApiError> {\n       if claims.sub == user_id || claims.is_admin {\n           return Ok(());\n       }\n       Err(ApiError::AuthorizationError(\n           format!(\"Voc√™ n√£o tem permiss√£o para {} este usu√°rio\", action)\n       ))\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 35,
    "title": "Tratamento de consultas grandes",
    "description": "Implementar pagina√ß√£o com cursor para melhor performance",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(serde::Deserialize)]\n   pub struct CursorPaginatedQuery {\n       pub cursor: Option<String>,\n       pub page_size: Option<u64>,\n       pub order: Option<String>,\n   }\n   \n   pub async fn list_users_cursor(\n       pool: web::Data<DbPool>,\n       query: web::Query<CursorPaginatedQuery>,\n   ) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o com cursor ao inv√©s de offset\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "cache"
    ],
    "context": "Controllers"
  },
  {
    "id": 36,
    "title": "Rota√ß√£o de JWT Key",
    "description": "Implementar suporte para rota√ß√£o de chaves JWT",
    "priority": "m√©dia",
    "category": "Middleware",
    "code_example": "struct JwtKeyManager {\n       current_key: String,\n       previous_keys: Vec<String>,\n       rotation_timestamp: DateTime<Utc>,\n   }\n   \n   impl JwtKeyManager {\n       fn validate_token(&self, token: &str) -> Result<TokenClaims, ApiError> {\n           // Tentar a chave atual primeiro\n           match decode_token(token, &self.current_key) {\n               Ok(claims) => return Ok(claims),\n               Err(_) => {\n                   // Tentar chaves antigas\n                   for key in &self.previous_keys {\n                       if let Ok(claims) = decode_token(token, key) {\n                           return Ok(claims);\n                       }\n                   }\n               }\n           }\n           // Se chegou aqui, nenhuma chave funcionou\n           Err(ApiError::AuthenticationError(\"Token inv√°lido\".to_string()))\n       }\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "jwt"
    ],
    "context": "Middleware"
  },
  {
    "id": 37,
    "title": "Inje√ß√£o de depend√™ncia para middleware",
    "description": "Implementar DI para facilitar testes",
    "priority": "m√©dia",
    "category": "Middleware",
    "code_example": "pub struct AuthMiddlewareFactory<T: TokenValidator> {\n       validator: Arc<T>,\n   }\n   \n   pub trait TokenValidator: Send + Sync + 'static {\n       fn validate(&self, token: &str) -> Result<TokenClaims, ApiError>;\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "test"
    ],
    "context": "Middleware"
  },
  {
    "id": 38,
    "title": "Configura√ß√£o avan√ßada de CSP",
    "description": "Adicionar suporte para configura√ß√µes mais detalhadas",
    "priority": "m√©dia",
    "category": "Middleware",
    "code_example": "pub struct CspBuilder {\n       directives: HashMap<String, Vec<String>>,\n   }\n   \n   impl CspBuilder {\n       pub fn new() -> Self {\n           let mut builder = Self { directives: HashMap::new() };\n           // Configurar valores padr√£o\n           builder.add_directive(\"default-src\", vec![\"'self'\"]);\n           builder\n       }\n       \n       pub fn add_directive<S: Into<String>>(mut self, name: S, values: Vec<&str>) -> Self {\n           let name = name.into();\n           let values = values.into_iter().map(String::from).collect();\n           self.directives.insert(name, values);\n           self\n       }\n       \n       pub fn build(&self) -> String {\n           // Construir a string CSP\n           self.directives.iter()\n               .map(|(name, values)| format!(\"{} {}\", name, values.join(\" \")))\n               .collect::<Vec<_>>()\n               .join(\"; \")\n       }\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "config"
    ],
    "context": "Middleware"
  },
  {
    "id": 39,
    "title": "Logging de eventos de seguran√ßa",
    "description": "Adicionar rastreamento para eventos de seguran√ßa importantes",
    "priority": "m√©dia",
    "category": "Middleware",
    "code_example": "fn record_security_event(\n       req: &ServiceRequest, \n       event_type: &str, \n       details: &str\n   ) {\n       let ip = req.connection_info().realip_remote_addr().unwrap_or(\"unknown\").to_string();\n       let user_agent = req.headers().get(\"User-Agent\")\n           .and_then(|h| h.to_str().ok())\n           .unwrap_or(\"unknown\");\n           \n       info!(\n           event_type = event_type,\n           ip = ip,\n           user_agent = user_agent,\n           details = details,\n           \"Evento de seguran√ßa detectado\"\n       );\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "seguran√ßa",
      "log",
      "webhook"
    ],
    "context": "Middleware"
  },
  {
    "id": 40,
    "title": "Expans√£o do rate limiter",
    "description": "Adicionar funcionalidades como rate limiting din√¢mico",
    "priority": "m√©dia",
    "category": "Middleware",
    "code_example": "pub struct DynamicRateLimiter {\n       base_capacity: u32,\n       base_refill_rate: f64,\n       user_factors: Arc<RwLock<HashMap<String, f64>>>,\n   }\n   \n   impl DynamicRateLimiter {\n       pub fn adjust_user_factor(&self, user_id: &str, factor: f64) {\n           let mut factors = self.user_factors.write().unwrap();\n           factors.insert(user_id.to_string(), factor);\n       }\n       \n       pub fn get_limit_for_user(&self, user_id: &str) -> (u32, f64) {\n           let factors = self.user_factors.read().unwrap();\n           let factor = factors.get(user_id).copied().unwrap_or(1.0);\n           \n           let capacity = (self.base_capacity as f64 * factor) as u32;\n           let refill_rate = self.base_refill_rate * factor;\n           \n           (capacity, refill_rate)\n       }\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "rate-limit"
    ],
    "context": "Middleware"
  },
  {
    "id": 41,
    "title": "Preven√ß√£o avan√ßada de CSRF",
    "description": "Implementar verifica√ß√µes de origem (Origin/Referer)",
    "priority": "m√©dia",
    "category": "Middleware",
    "code_example": "fn validate_request_origin(req: &ServiceRequest, allowed_origins: &[String]) -> Result<(), ApiError> {\n       let origin = req.headers().get(\"Origin\").and_then(|h| h.to_str().ok());\n       let referer = req.headers().get(\"Referer\").and_then(|h| h.to_str().ok());\n       \n       match (origin, referer) {\n           (Some(origin), _) if allowed_origins.iter().any(|o| o == origin) => Ok(()),\n           (None, Some(referer)) if allowed_origins.iter().any(|o| referer.starts_with(o)) => Ok(()),\n           _ => Err(ApiError::ForbiddenError(\"Origem inv√°lida\".to_string())),\n       }\n   }",
    "status": "pendente",
    "tags": [
      "middleware"
    ],
    "context": "Middleware"
  },
  {
    "id": 42,
    "title": "Valida√ß√£o de for√ßa de senha",
    "description": "Adicionar valida√ß√£o direta no DTO",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[validate(custom = \"validate_password_strength\")]\n   pub password: Option<String>,\n   \n   // Fun√ß√£o auxiliar\n   fn validate_password_strength(password: &str) -> Result<(), ValidationError> {\n       // Implementa√ß√£o aqui\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "password"
    ],
    "context": "Models"
  },
  {
    "id": 43,
    "title": "Documenta√ß√£o OpenAPI",
    "description": "Adicionar anota√ß√µes para documenta√ß√£o API",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "/// Modelo para senha tempor√°ria\n   /// \n   /// @schema TemporaryPassword\n   #[derive(Debug, Serialize, Deserialize, Clone)]\n   pub struct TemporaryPassword {\n       // campos...\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "api"
    ],
    "context": "Models"
  },
  {
    "id": 44,
    "title": "Timestamp de expira√ß√£o",
    "description": "Adicionar campo para expira√ß√£o baseada em tempo",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub expires_at: DateTime<Utc>,\n   \n   // No construtor\n   pub fn new(user_id: String, password_hash: String, usage_limit: i32, expiration_hours: i32) -> Self {\n       let expires_at = Utc::now() + Duration::hours(expiration_hours as i64);\n       Self {\n           // outros campos\n           expires_at,\n       }\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 45,
    "title": "Hist√≥rico de senhas tempor√°rias",
    "description": "Implementar estruturas para rastrear hist√≥rico",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct TemporaryPasswordHistory {\n       pub id: String,\n       pub user_id: String,\n       pub created_at: DateTime<Utc>,\n       pub expired_at: DateTime<Utc>,\n       pub was_used: bool,\n       pub usage_count: i32,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "password"
    ],
    "context": "Models"
  },
  {
    "id": 46,
    "title": "Implementar m√©todo de verifica√ß√£o",
    "description": "Criar m√©todo para verificar se a senha expirou",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub fn is_expired(&self) -> bool {\n       self.expires_at < Utc::now() || self.usage_count >= self.usage_limit\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "password"
    ],
    "context": "Models"
  },
  {
    "id": 47,
    "title": "Limpeza autom√°tica",
    "description": "Implementar fun√ß√£o para limpar senhas expiradas",
    "priority": "m√©dia",
    "category": "Repositories",
    "code_example": "pub async fn cleanup_expired_passwords(pool: Arc<DbPool>) -> Result<usize, ApiError> {\n       let conn = pool.get()?;\n       let rows_affected = conn.execute(\n           \"DELETE FROM temporary_passwords WHERE (created_at < datetime('now', '-24 hours') OR usage_count >= usage_limit) AND is_active = TRUE\",\n           params![],\n       )?;\n       Ok(rows_affected)\n   }",
    "status": "pendente",
    "tags": [
      "repositories",
      "password"
    ],
    "context": "Repositories"
  },
  {
    "id": 48,
    "title": "M√©tricas de uso",
    "description": "Adicionar fun√ß√£o para obter estat√≠sticas",
    "priority": "m√©dia",
    "category": "Repositories",
    "code_example": "pub async fn get_usage_stats(pool: Arc<DbPool>) -> Result<TemporaryPasswordStats, ApiError> {\n       // Implementa√ß√£o para obter estat√≠sticas\n   }",
    "status": "pendente",
    "tags": [
      "repositories"
    ],
    "context": "Repositories"
  },
  {
    "id": 49,
    "title": "Pagina√ß√£o",
    "description": "Implementar fun√ß√µes com suporte a pagina√ß√£o",
    "priority": "m√©dia",
    "category": "Repositories",
    "code_example": "pub async fn list_with_pagination(\n       pool: Arc<DbPool>, \n       user_id: &str,\n       page: u64,\n       page_size: u64\n   ) -> Result<(Vec<TemporaryPassword>, u64), ApiError> {\n       // Implementa√ß√£o com pagina√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "repositories"
    ],
    "context": "Repositories"
  },
  {
    "id": 50,
    "title": "Notifica√ß√£o de quebra de seguran√ßa",
    "description": "Adicionar fun√ß√£o para verificar tentativas de uso",
    "priority": "m√©dia",
    "category": "Repositories",
    "code_example": "pub async fn record_usage_attempt(\n       pool: Arc<DbPool>,\n       temp_password_id: &str,\n       success: bool,\n       ip_address: Option<&str>,\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o para registrar tentativas\n   }",
    "status": "pendente",
    "tags": [
      "repositories",
      "seguran√ßa",
      "email"
    ],
    "context": "Repositories"
  },
  {
    "id": 51,
    "title": "Cache de verifica√ß√£o",
    "description": "Implementar cache para verifica√ß√µes frequentes",
    "priority": "m√©dia",
    "category": "Repositories",
    "code_example": "pub async fn find_with_cache(\n       pool: Arc<DbPool>,\n       cache: &moka::future::Cache<String, TemporaryPassword>,\n       user_id: &str\n   ) -> Result<Option<TemporaryPassword>, ApiError> {\n       // Implementa√ß√£o com cache\n   }",
    "status": "pendente",
    "tags": [
      "repositories",
      "cache"
    ],
    "context": "Repositories"
  },
  {
    "id": 52,
    "title": "Configura√ß√£o din√¢mica",
    "description": "Permitir ajustes baseados em hardware",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn configure_params(\n       memory_cost: Option<u32>,\n       time_cost: Option<u32>,\n       parallelism: Option<u32>\n   ) -> Argon2Params {\n       Argon2Params {\n           memory_cost: memory_cost.unwrap_or(DEFAULT_MEMORY_COST),\n           time_cost: time_cost.unwrap_or(DEFAULT_TIME_COST),\n           parallelism: parallelism.unwrap_or(DEFAULT_PARALLELISM),\n       }\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "config"
    ],
    "context": "Utils"
  },
  {
    "id": 53,
    "title": "Logging seguro",
    "description": "Adicionar logging para eventos de seguran√ßa",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn hash_password(password: &str) -> Result<String, String> {\n       // implementa√ß√£o existente\n       tracing::debug!(\"Senha hashada com par√¢metros: m={}, t={}, p={}\", \n           DEFAULT_MEMORY_COST, DEFAULT_TIME_COST, DEFAULT_PARALLELISM);\n       // resto da implementa√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "seguran√ßa",
      "log",
      "webhook"
    ],
    "context": "Utils"
  },
  {
    "id": 54,
    "title": "Detec√ß√£o de ataques",
    "description": "Adicionar temporizador para mitigar timing attacks",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn verify_password(password: &str, hash: &str) -> Result<bool, String> {\n       let start = std::time::Instant::now();\n       let result = argon2::verify_encoded(hash, password.as_bytes())\n           .map_err(|e| format!(\"Erro ao verificar senha: {}\", e));\n           \n       // Garantir tempo m√≠nimo para evitar timing attacks\n       let elapsed = start.elapsed();\n       if elapsed < std::time::Duration::from_millis(MIN_VERIFICATION_TIME) {\n           std::thread::sleep(std::time::Duration::from_millis(MIN_VERIFICATION_TIME) - elapsed);\n       }\n       \n       result\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 55,
    "title": "Upgrading de par√¢metros",
    "description": "Adicionar fun√ß√£o para upgrade de hashes antigos",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn needs_rehash(hash: &str) -> bool {\n       // Verificar se o hash atual usa par√¢metros inferiores aos atuais\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 56,
    "title": "Salt personalizado",
    "description": "Permitir uso de salt personalizado",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn hash_password_with_salt(password: &str, salt: &[u8]) -> Result<String, String> {\n       // Implementa√ß√£o com salt fornecido\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 57,
    "title": "Rastreamento de IPs e dispositivos",
    "description": "Adicionar campos para audit trail",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub last_login_ip: Option<String>,\n   pub last_login_device: Option<String>,\n   pub known_ips: Vec<String>, // Serializado como JSON",
    "status": "pendente",
    "tags": [
      "models",
      "log"
    ],
    "context": "Models"
  },
  {
    "id": 58,
    "title": "M√©tricas de usu√°rio",
    "description": "Adicionar campos para estat√≠sticas",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub login_count: i32,\n   pub last_password_change: Option<DateTime<Utc>>,\n   pub password_history: Vec<PasswordHistoryEntry>, // Para evitar reuso",
    "status": "pendente",
    "tags": [
      "models",
      "user"
    ],
    "context": "Models"
  },
  {
    "id": 59,
    "title": "Status extendido",
    "description": "Adicionar enum para representar status mais detalhado",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n   pub enum UserStatus {\n       Active,\n       Inactive,\n       PendingVerification,\n       Suspended,\n       Locked,\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 60,
    "title": "Verifica√ß√£o avan√ßada",
    "description": "Adicionar m√©todos para verifica√ß√£o de permiss√µes",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub fn can_access(&self, resource: &str) -> bool {\n       // Verifica√ß√£o mais avan√ßada de permiss√µes\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 61,
    "title": "Sanitiza√ß√£o de email/username",
    "description": "Adicionar m√©todos para normaliza√ß√£o",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub fn normalize_email(email: &str) -> String {\n       // Implementa√ß√£o para normalizar email antes de armazenar\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "user",
      "email"
    ],
    "context": "Models"
  },
  {
    "id": 62,
    "title": "Verifica√ß√£o contra senhas vazadas",
    "description": "Integrar com APIs de verifica√ß√£o",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub async fn check_if_password_is_pwned(password: &str) -> Result<bool, ApiError> {\n       // Implementa√ß√£o usando k-anonimidade e API HIBP\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "password",
      "api"
    ],
    "context": "Utils"
  },
  {
    "id": 63,
    "title": "Sugest√£o de senha segura",
    "description": "Adicionar gerador de senhas fortes",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn generate_secure_password(length: usize) -> String {\n       // Implementa√ß√£o para gerar senha segura aleat√≥ria\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "password"
    ],
    "context": "Utils"
  },
  {
    "id": 64,
    "title": "Configura√ß√£o por perfil",
    "description": "Adicionar regras diferenciadas por tipo de usu√°rio",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn check_password_strength_for_role(password: &str, role: &str) -> Result<(), Vec<String>> {\n       // Verifica√ß√£o adaptada por tipo de usu√°rio/papel\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "user",
      "config"
    ],
    "context": "Utils"
  },
  {
    "id": 65,
    "title": "Dicion√°rio personalizado",
    "description": "Implementar verifica√ß√£o contra palavras comuns",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn load_custom_dictionary(path: &str) -> Result<(), ApiError> {\n       // Carrega lista personalizada de palavras proibidas\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 66,
    "title": "Verifica√ß√£o de contexto",
    "description": "Evitar senhas baseadas em informa√ß√µes do usu√°rio",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn check_context_based_password(\n       password: &str, \n       user_info: &UserContextInfo\n   ) -> Result<(), Vec<String>> {\n       // Verifica se a senha cont√©m informa√ß√µes do usu√°rio\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "password",
      "user"
    ],
    "context": "Utils"
  },
  {
    "id": 67,
    "title": "Suporte a tokens com escopo",
    "description": "Adicionar campo de permiss√µes espec√≠ficas",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub struct TokenClaims {\n       // Campos existentes\n       pub scopes: Vec<String>, // Escopos de permiss√£o\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "jwt"
    ],
    "context": "Models"
  },
  {
    "id": 68,
    "title": "Hist√≥rico de logins",
    "description": "Adicionar estrutura para rastrear sess√µes",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct LoginHistory {\n       pub id: String,\n       pub user_id: String,\n       pub ip_address: String,\n       pub user_agent: String,\n       pub login_time: DateTime<Utc>,\n       pub success: bool,\n       pub failure_reason: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "log",
      "auth"
    ],
    "context": "Models"
  },
  {
    "id": 69,
    "title": "Detec√ß√£o de dispositivos",
    "description": "Melhorar reconhecimento de dispositivos",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct DeviceInfo {\n       pub device_id: String,\n       pub device_type: DeviceType,\n       pub os: String,\n       pub browser: String,\n       pub is_mobile: bool,\n       pub is_trusted: bool,\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 70,
    "title": "Rota√ß√£o de tokens",
    "description": "Suporte para rota√ß√£o segura de refresh tokens",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "impl RefreshToken {\n       pub fn rotate(&self) -> Self {\n           let new_expires_at = Utc::now() + Duration::days(self.expiration_days);\n           let mut new_token = self.clone();\n           new_token.id = Uuid::new_v4().to_string();\n           new_token.previous_token_id = Some(self.id.clone());\n           new_token.expires_at = new_expires_at;\n           new_token\n       }\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "jwt"
    ],
    "context": "Models"
  },
  {
    "id": 71,
    "title": "Geolocaliza√ß√£o de sess√µes",
    "description": "Adicionar informa√ß√µes geogr√°ficas",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct LocationInfo {\n       pub country: Option<String>,\n       pub city: Option<String>,\n       pub latitude: Option<f64>,\n       pub longitude: Option<f64>,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "geolocation"
    ],
    "context": "Models"
  },
  {
    "id": 72,
    "title": "Prote√ß√£o contra ataques de for√ßa bruta",
    "description": "Implementar backoff exponencial",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "fn calculate_lockout_duration(failed_attempts: i32) -> Duration {\n       let base_seconds = 30;\n       let factor = 2_i32.pow(std::cmp::min(failed_attempts, 10) as u32);\n       Duration::seconds(base_seconds * factor as i64)\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "seguran√ßa"
    ],
    "context": "Services"
  },
  {
    "id": 73,
    "title": "Detec√ß√£o de anomalias",
    "description": "Adicionar verifica√ß√µes de comportamento suspeito",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub async fn check_for_suspicious_activity(\n       pool: &DbPool,\n       user_id: &str,\n       ip_address: &str,\n       user_agent: &str\n   ) -> Result<SuspiciousActivityLevel, ApiError> {\n       // Implementa√ß√£o para detec√ß√£o de anomalias\n   }",
    "status": "pendente",
    "tags": [
      "services"
    ],
    "context": "Services"
  },
  {
    "id": 74,
    "title": "Suporte a m√∫ltiplos fatores",
    "description": "Melhorar integra√ß√£o com 2FA/MFA",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub async fn verify_multi_factor(\n       pool: &DbPool,\n       user_id: &str,\n       verification_type: MfaType,\n       verification_code: &str\n   ) -> Result<bool, ApiError> {\n       // Implementa√ß√£o verifica√ß√£o multi-fator\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "2fa"
    ],
    "context": "Services"
  },
  {
    "id": 75,
    "title": "Revoga√ß√£o em cascata",
    "description": "Revogar todas as sess√µes ao mudar senha",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub async fn revoke_all_sessions_for_user(\n       pool: &DbPool,\n       user_id: &str,\n       reason: &str\n   ) -> Result<usize, ApiError> {\n       // Implementa√ß√£o para revogar todas as sess√µes\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "password"
    ],
    "context": "Services"
  },
  {
    "id": 76,
    "title": "Analytics de autentica√ß√£o",
    "description": "Coletar m√©tricas para dashboard",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub async fn get_auth_statistics(\n       pool: &DbPool,\n       start_date: DateTime<Utc>,\n       end_date: DateTime<Utc>\n   ) -> Result<AuthStatistics, ApiError> {\n       // Implementa√ß√£o para coletar estat√≠sticas\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "jwt",
      "auth"
    ],
    "context": "Services"
  },
  {
    "id": 77,
    "title": "Verifica√ß√£o de reputa√ß√£o",
    "description": "Implementar verifica√ß√£o de entregabilidade",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub async fn check_email_reputation(email: &str) -> Result<EmailReputation, ApiError> {\n       // Implementa√ß√£o para verificar reputa√ß√£o do dom√≠nio/email\n   }",
    "status": "pendente",
    "tags": [
      "services"
    ],
    "context": "Services"
  },
  {
    "id": 78,
    "title": "Templates HTML/Text",
    "description": "Melhorar suporte a vers√µes alternativas",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub struct EmailTemplate {\n       pub html_version: String,\n       pub text_version: String,\n       pub subject: String,\n       pub preview_text: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "services"
    ],
    "context": "Services"
  },
  {
    "id": 79,
    "title": "Providers alternativos",
    "description": "Adicionar suporte para m√∫ltiplos provedores",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub enum EmailProvider {\n       SMTP(SmtpConfig),\n       SendGrid(SendGridConfig),\n       Mailgun(MailgunConfig),\n       AmazonSES(SESConfig),\n   }",
    "status": "pendente",
    "tags": [
      "services"
    ],
    "context": "Services"
  },
  {
    "id": 80,
    "title": "Assinatura DKIM/SPF",
    "description": "Implementar assinatura de emails",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub fn configure_dkim(\n       private_key_path: &str,\n       selector: &str,\n       domain: &str\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o para configurar DKIM\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "email"
    ],
    "context": "Services"
  },
  {
    "id": 81,
    "title": "An√°lise de engajamento",
    "description": "Rastrear abertura e cliques",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub struct EmailTrackingData {\n       pub opened: bool,\n       pub opened_at: Option<DateTime<Utc>>,\n       pub clicked: bool,\n       pub clicked_at: Option<DateTime<Utc>>,\n       pub clicked_link: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "risk"
    ],
    "context": "Services"
  },
  {
    "id": 82,
    "title": "Versionamento de API",
    "description": "Adicionar informa√ß√µes de vers√£o",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub struct ApiResponseEnvelope<T> {\n       pub data: ApiResponse<T>,\n       pub api_version: String,\n       pub request_id: String,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "api"
    ],
    "context": "Models"
  },
  {
    "id": 83,
    "title": "Metadados de performance",
    "description": "Adicionar informa√ß√µes de tempo",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub struct ApiResponseMetadata {\n       pub processing_time_ms: u64,\n       pub database_queries: u32,\n       pub cached_results: bool,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "cache"
    ],
    "context": "Models"
  },
  {
    "id": 84,
    "title": "Links HATEOAS",
    "description": "Adicionar navega√ß√£o para APIs RESTful",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Serialize)]\n   pub struct ApiLink {\n       pub rel: String,\n       pub href: String,\n       pub method: String,\n   }\n   \n   // Na struct ApiResponse\n   pub links: Vec<ApiLink>,",
    "status": "pendente",
    "tags": [
      "models",
      "api"
    ],
    "context": "Models"
  },
  {
    "id": 85,
    "title": "Sanitiza√ß√£o de erros",
    "description": "Adicionar fun√ß√£o para ambiente de produ√ß√£o",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub fn sanitize_for_production<T>(self) -> Self {\n       if self.success {\n           return self;\n       }\n       \n       // Em produ√ß√£o, remover detalhes sens√≠veis dos erros\n       if std::env::var(\"ENVIRONMENT\").unwrap_or_default() == \"production\" {\n           return Self {\n               success: false,\n               message: \"Ocorreu um erro ao processar sua solicita√ß√£o\".to_string(),\n               data: None,\n               errors: None,\n           };\n       }\n       \n       self\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 86,
    "title": "Compress√£o de resposta",
    "description": "Implementar suporte para grandes payloads",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub enum CompressionType {\n       None,\n       Gzip,\n       Brotli,\n   }\n   \n   // M√©todo para comprimir respostas grandes\n   pub fn with_compression(self, compression: CompressionType) -> HttpResponse {\n       // Implementa√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 87,
    "title": "Controle de acesso mais fino",
    "description": "Implementar verifica√ß√£o baseada em permiss√µes",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "fn check_permission(\n       claims: &TokenClaims, \n       permission: &str,\n       resource_id: Option<&str>\n   ) -> Result<(), ApiError> {\n       // Verifica√ß√£o de permiss√µes mais detalhada\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 88,
    "title": "Suporte para bulk operations",
    "description": "Adicionar endpoints para opera√ß√µes em lote",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn bulk_update_users(\n       pool: web::Data<DbPool>,\n       update_dto: web::Json<BulkUpdateUsersDto>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o para atualiza√ß√£o em lote\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "api"
    ],
    "context": "Controllers"
  },
  {
    "id": 89,
    "title": "Versionamento de endpoints",
    "description": "Adicionar suporte para m√∫ltiplas vers√µes",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub mod v1 {\n       pub async fn get_user(...) -> Result<impl Responder, ApiError> {\n           // Implementa√ß√£o v1\n       }\n   }\n   \n   pub mod v2 {\n       pub async fn get_user(...) -> Result<impl Responder, ApiError> {\n           // Implementa√ß√£o v2 com campos adicionais\n       }\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "api"
    ],
    "context": "Controllers"
  },
  {
    "id": 90,
    "title": "Auditoria avan√ßada",
    "description": "Registrar todas as altera√ß√µes",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "fn log_user_change(\n       pool: &DbPool, \n       user_id: &str,\n       admin_id: Option<&str>,\n       change_type: &str,\n       old_value: Option<&str>,\n       new_value: Option<&str>,\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o de log de auditoria\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "log"
    ],
    "context": "Controllers"
  },
  {
    "id": 91,
    "title": "Respostas condicionais",
    "description": "Suporte para ETag e cache",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn get_user_with_caching(\n       pool: web::Data<DbPool>,\n       path: web::Path<String>,\n       claims: web::ReqData<TokenClaims>,\n       req: HttpRequest,\n   ) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o com suporte a ETag e If-None-Match\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "cache"
    ],
    "context": "Controllers"
  },
  {
    "id": 92,
    "title": "Suporte para m√∫ltiplos tipos de 2FA",
    "description": "Adicionar mais m√©todos",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub enum TwoFactorType {\n       Totp,\n       Sms,\n       Email,\n       Push,\n       WebAuthn,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "2fa"
    ],
    "context": "Models"
  },
  {
    "id": 93,
    "title": "Hist√≥rico de uso",
    "description": "Rastrear uso de c√≥digos de backup",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct BackupCodeUsage {\n       pub code_hash: String, // Hash do c√≥digo usado\n       pub used_at: DateTime<Utc>,\n       pub ip_address: Option<String>,\n       pub user_agent: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "backup"
    ],
    "context": "Models"
  },
  {
    "id": 94,
    "title": "Configura√ß√£o adaptativa",
    "description": "Ajustar par√¢metros por n√≠vel de risco",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub struct TotpConfig {\n       pub digits: u32,\n       pub step: u64,\n       pub window: u64,\n   }\n   \n   pub fn get_totp_config(risk_level: RiskLevel) -> TotpConfig {\n       match risk_level {\n           RiskLevel::Low => TotpConfig { digits: 6, step: 30, window: 1 },\n           RiskLevel::Medium => TotpConfig { digits: 6, step: 30, window: 0 },\n           RiskLevel::High => TotpConfig { digits: 8, step: 15, window: 0 },\n       }\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "config",
      "risk"
    ],
    "context": "Models"
  },
  {
    "id": 95,
    "title": "Notifica√ß√µes de seguran√ßa",
    "description": "Adicionar eventos para notifica√ß√£o",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub enum TwoFactorEvent {\n       Enabled,\n       Disabled,\n       BackupCodeUsed,\n       FailedAttempt,\n       ConfigurationChanged,\n   }\n   \n   pub struct TwoFactorNotification {\n       pub event: TwoFactorEvent,\n       pub user_id: String,\n       pub timestamp: DateTime<Utc>,\n       pub details: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "seguran√ßa",
      "email",
      "webhook"
    ],
    "context": "Models"
  },
  {
    "id": 96,
    "title": "QR code personalizado",
    "description": "Adicionar marca d'√°gua e customiza√ß√£o",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Deserialize)]\n   pub struct QrCodeCustomization {\n       pub size: u32,\n       pub dark_color: String,\n       pub light_color: String,\n       pub logo_url: Option<String>,\n       pub border_size: u32,\n   }\n   \n   pub async fn generate_custom_qr(\n       pool: web::Data<DbPool>,\n       options: web::Json<QrCodeCustomization>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para gerar QR code personalizado\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 97,
    "title": "Mascaramento de dados sens√≠veis",
    "description": "Implementar filtro para PII e credenciais",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "fn mask_sensitive_fields(record: &tracing::span::Record) -> tracing::span::Record {\n       // Implementa√ß√£o para mascarar campos como senhas, tokens, etc.\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 98,
    "title": "Rastreamento de opera√ß√µes",
    "description": "Adicionar suporte para OpenTelemetry",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn init_opentelemetry(service_name: &str) -> Result<(), ApiError> {\n       // Configura√ß√£o de exporta√ß√£o para sistemas como Jaeger/Zipkin\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 99,
    "title": "Logs para diferentes ambientes",
    "description": "Configura√ß√£o adaptativa",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub enum Environment {\n       Development,\n       Staging,\n       Production,\n   }\n   \n   pub fn configure_tracing_for_env(env: Environment) {\n       match env {\n           Environment::Development => { /* config com mais detalhes */ },\n           Environment::Staging => { /* config balanceada */ },\n           Environment::Production => { /* config otimizada e segura */ },\n       }\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "log",
      "config"
    ],
    "context": "Utils"
  },
  {
    "id": 100,
    "title": "Armazenamento seguro",
    "description": "Rota√ß√£o e backup de logs",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub struct LogRetentionPolicy {\n       pub max_file_size_mb: u64,\n       pub max_files: u32,\n       pub rotation_period: Duration,\n       pub compression: bool,\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "log",
      "database",
      "backup"
    ],
    "context": "Utils"
  },
  {
    "id": 101,
    "title": "Alerta baseado em logs",
    "description": "Detec√ß√£o de padr√µes cr√≠ticos",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn configure_log_alerting(patterns: Vec<AlertPattern>) -> Result<(), ApiError> {\n       // Configura√ß√£o para enviar alertas quando certos padr√µes aparecem nos logs\n   }\n   \n   pub struct AlertPattern {\n       pub regex: String,\n       pub level: tracing::Level,\n       pub channel: AlertChannel,\n       pub cooldown: Duration,\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "log"
    ],
    "context": "Utils"
  },
  {
    "id": 102,
    "title": "Implementa√ß√£o de CAPTCHA",
    "description": "Adicionar prote√ß√£o contra bots",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize, Validate)]\n   pub struct LoginWithCaptchaDto {\n       #[validate(length(min = 3, max = 100))]\n       pub username_or_email: String,\n       #[validate(length(min = 8))]\n       pub password: String,\n       #[validate(required)]\n       pub captcha_token: String,\n   }\n   \n   async fn verify_captcha(token: &str) -> Result<bool, ApiError> {\n       // Implementa√ß√£o para verificar token de CAPTCHA com servi√ßo externo\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa"
    ],
    "context": "Controllers"
  },
  {
    "id": 103,
    "title": "Fingerprinting de dispositivo",
    "description": "Identificar dispositivos para seguran√ßa adicional",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub struct DeviceFingerprint {\n       pub ip_address: String,\n       pub user_agent: String,\n       pub screen_resolution: Option<String>,\n       pub timezone: Option<String>,\n       pub languages: Vec<String>,\n       pub platform: String,\n   }\n   \n   pub async fn login_with_fingerprint(\n       pool: web::Data<DbPool>,\n       login_dto: web::Json<LoginDto>,\n       fingerprint: web::Json<DeviceFingerprint>,\n       config: web::Data<Config>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o com verifica√ß√£o de dispositivos conhecidos\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa"
    ],
    "context": "Controllers"
  },
  {
    "id": 104,
    "title": "M√©tricas detalhadas",
    "description": "Registrar eventos de autentica√ß√£o para an√°lise",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub struct AuthMetrics {\n       pub attempt_timestamp: DateTime<Utc>,\n       pub success: bool,\n       pub ip_address: String,\n       pub geolocation: Option<GeoLocation>,\n       pub device_type: String,\n       pub failed_reason: Option<String>,\n       pub processing_time_ms: u64,\n   }\n   \n   fn record_auth_metrics(metrics: AuthMetrics) {\n       // Implementa√ß√£o para registrar m√©tricas\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "jwt",
      "auth",
      "webhook",
      "risk"
    ],
    "context": "Controllers"
  },
  {
    "id": 105,
    "title": "Limites adaptativos de tentativas",
    "description": "Ajustar limites baseados em fatores de risco",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub enum RiskFactor {\n       NewLocation,\n       UnknownDevice,\n       MultipleFailures,\n       SuspiciousActivity,\n       NormalActivity,\n   }\n   \n   fn calculate_attempt_limit(factors: &[RiskFactor]) -> u32 {\n       let base_limit = 5;\n       \n       factors.iter().fold(base_limit, |limit, factor| {\n           match factor {\n               RiskFactor::NormalActivity => limit,\n               RiskFactor::NewLocation => limit - 1,\n               RiskFactor::UnknownDevice => limit - 1,\n               RiskFactor::MultipleFailures => limit - 2,\n               RiskFactor::SuspiciousActivity => 2, // Limite estrito para atividades suspeitas\n           }\n       })\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "risk",
      "rate-limit"
    ],
    "context": "Controllers"
  },
  {
    "id": 106,
    "title": "Login progressivo",
    "description": "Implementar autentica√ß√£o em etapas",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub enum AuthStage {\n       Initial,\n       TwoFactor,\n       RecoveryCode,\n       SecurityQuestions,\n       Complete,\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub struct ProgressiveAuthResponse {\n       pub stage: AuthStage,\n       pub session_id: String,\n       pub next_action: String,\n       pub expires_in: i64,\n   }\n   \n   pub async fn start_progressive_auth(\n       pool: web::Data<DbPool>,\n       credentials: web::Json<LoginDto>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o de fluxo de login progressivo\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "jwt",
      "log",
      "auth"
    ],
    "context": "Controllers"
  },
  {
    "id": 107,
    "title": "Verifica√ß√£o de dispositivo confi√°vel",
    "description": "Permitir dispositivos sem 2FA",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize)]\n   pub struct TrustedDeviceRequest {\n       pub device_name: String,\n       pub remember_device: bool,\n       pub device_id: String,\n   }\n   \n   pub async fn mark_device_as_trusted(\n       pool: web::Data<DbPool>,\n       req: web::Json<TrustedDeviceRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para marcar dispositivo como confi√°vel\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "2fa"
    ],
    "context": "Controllers"
  },
  {
    "id": 108,
    "title": "Rastreamento de sess√µes 2FA",
    "description": "Manter hist√≥rico para seguran√ßa",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct TwoFactorSessionLog {\n       pub id: String,\n       pub user_id: String,\n       pub verification_time: DateTime<Utc>,\n       pub success: bool,\n       pub method: String,\n       pub ip_address: String,\n       pub device_info: String,\n   }\n   \n   fn log_2fa_attempt(\n       pool: &DbPool,\n       user_id: &str,\n       success: bool,\n       method: &str,\n       ip: &str,\n       device: &str,\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o para registrar tentativa de 2FA\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa",
      "2fa"
    ],
    "context": "Controllers"
  },
  {
    "id": 109,
    "title": "M√©todos alternativos de 2FA",
    "description": "Suporte a SMS e email",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub enum TwoFactorMethod {\n       Totp,\n       Sms,\n       Email,\n       PushNotification,\n   }\n   \n   pub async fn setup_alternative_2fa(\n       pool: web::Data<DbPool>,\n       method: web::Path<String>,\n       contact: web::Json<AlternativeContactDto>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para configurar 2FA alternativo\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "email",
      "2fa"
    ],
    "context": "Controllers"
  },
  {
    "id": 110,
    "title": "Pol√≠ticas de 2FA por grupo",
    "description": "Aplicar regras por grupos de usu√°rios",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub struct TwoFactorPolicy {\n       pub group_id: String,\n       pub require_2fa: bool,\n       pub allowed_methods: Vec<TwoFactorMethod>,\n       pub grace_period_days: u32,\n       pub bypass_ips: Vec<String>,\n   }\n   \n   async fn check_2fa_policy(\n       pool: &DbPool,\n       user_id: &str,\n       ip_address: &str,\n   ) -> Result<TwoFactorRequirement, ApiError> {\n       // Implementa√ß√£o para verificar pol√≠tica de 2FA aplic√°vel\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "user",
      "2fa"
    ],
    "context": "Controllers"
  },
  {
    "id": 111,
    "title": "QR code personalizado",
    "description": "Adicionar marca d'√°gua e customiza√ß√£o",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize)]\n   pub struct QrCodeCustomization {\n       pub size: u32,\n       pub dark_color: String,\n       pub light_color: String,\n       pub logo_url: Option<String>,\n       pub border_size: u32,\n   }\n   \n   pub async fn generate_custom_qr(\n       pool: web::Data<DbPool>,\n       options: web::Json<QrCodeCustomization>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para gerar QR code personalizado\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 112,
    "title": "Verifica√ß√£o progressiva",
    "description": "Permitir acesso limitado sem verifica√ß√£o",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub enum VerificationLevel {\n       None,\n       Pending,\n       Verified,\n   }\n   \n   pub struct EmailAccess {\n       pub level: VerificationLevel,\n       pub can_read: bool,\n       pub can_send: bool,\n       pub can_change_settings: bool,\n   }\n   \n   fn get_access_level(verification_status: &VerificationLevel) -> EmailAccess {\n       match verification_status {\n           VerificationLevel::None => EmailAccess {\n               level: VerificationLevel::None,\n               can_read: false,\n               can_send: false,\n               can_change_settings: false,\n           },\n           VerificationLevel::Pending => EmailAccess {\n               level: VerificationLevel::Pending,\n               can_read: true,\n               can_send: false,\n               can_change_settings: false,\n           },\n           VerificationLevel::Verified => EmailAccess {\n               level: VerificationLevel::Verified,\n               can_read: true,\n               can_send: true,\n               can_change_settings: true,\n           },\n       }\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 113,
    "title": "Link m√°gico de verifica√ß√£o",
    "description": "Implementar login via email",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn request_magic_link(\n       pool: web::Data<DbPool>,\n       email_dto: web::Json<EmailDto>,\n       config: web::Data<Config>,\n       email_service: web::Data<EmailService>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para gerar e enviar link m√°gico\n   }\n   \n   pub async fn verify_magic_link(\n       pool: web::Data<DbPool>,\n       token: web::Path<String>,\n       config: web::Data<Config>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para verificar link m√°gico e autenticar\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "log",
      "auth",
      "email"
    ],
    "context": "Controllers"
  },
  {
    "id": 114,
    "title": "Preven√ß√£o de abuso",
    "description": "Limitar tentativas de verifica√ß√£o",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "struct VerificationRateLimit {\n       pub email: String,\n       pub attempt_count: u32,\n       pub first_attempt: DateTime<Utc>,\n       pub last_attempt: DateTime<Utc>,\n       pub is_blocked: bool,\n       pub block_expires: Option<DateTime<Utc>>,\n   }\n   \n   async fn check_verification_rate_limit(\n       pool: &DbPool,\n       email: &str,\n   ) -> Result<bool, ApiError> {\n       // Implementa√ß√£o para verificar limites de tentativas\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 115,
    "title": "Templates personalizados",
    "description": "Suporte a temas e marcas",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct EmailTemplate {\n       pub name: String,\n       pub subject: String,\n       pub html_body: String,\n       pub text_body: String,\n       pub preview_text: String,\n       pub brand_id: Option<String>,\n       pub color_scheme: HashMap<String, String>,\n   }\n   \n   pub async fn set_verification_template(\n       pool: web::Data<DbPool>,\n       template: web::Json<EmailTemplate>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para configurar template personalizado\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 116,
    "title": "Consent din√¢mico",
    "description": "Permitir usu√°rio escolher escopos",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct ConsentRequest {\n       pub client: OAuthClientInfo,\n       pub scopes: Vec<ScopeInfo>,\n       pub user: UserBasicInfo,\n       pub consent_id: String,\n       pub expires_in: i64,\n   }\n   \n   #[derive(Debug, Deserialize)]\n   pub struct ConsentResponse {\n       pub consent_id: String,\n       pub approved_scopes: Vec<String>,\n       pub remember_consent: bool,\n   }\n   \n   pub async fn request_user_consent(\n       pool: web::Data<DbPool>,\n       auth_request: web::Query<AuthorizationRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para solicitar consentimento\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "user"
    ],
    "context": "Controllers"
  },
  {
    "id": 117,
    "title": "Token com limita√ß√£o de uso",
    "description": "Definir limite de utiliza√ß√µes",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct LimitedUseToken {\n       pub token: String,\n       pub max_uses: u32,\n       pub current_uses: u32,\n       pub expires_at: DateTime<Utc>,\n       pub is_active: bool,\n   }\n   \n   pub async fn issue_limited_token(\n       pool: web::Data<DbPool>,\n       request: web::Json<LimitedTokenRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para emitir token de uso limitado\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "jwt",
      "rate-limit"
    ],
    "context": "Controllers"
  },
  {
    "id": 118,
    "title": "Revoga√ß√£o em cascata",
    "description": "Revogar tokens relacionados",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn revoke_all_tokens(\n       pool: web::Data<DbPool>,\n       client_id: web::Path<String>,\n       user_id: Option<web::Query<String>>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para revogar todos os tokens relacionados\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "jwt"
    ],
    "context": "Controllers"
  },
  {
    "id": 119,
    "title": "Verifica√ß√µes de depend√™ncias",
    "description": "Testar componentes do sistema",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct HealthCheckResult {\n       pub status: HealthStatus,\n       pub version: String,\n       pub uptime: u64,\n       pub components: HashMap<String, ComponentHealth>,\n       pub timestamp: DateTime<Utc>,\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub struct ComponentHealth {\n       pub status: HealthStatus,\n       pub latency_ms: u64,\n       pub message: Option<String>,\n       pub last_checked: DateTime<Utc>,\n   }\n   \n   pub async fn check_system_health(\n       pool: web::Data<DbPool>,\n       cache: web::Data<Cache>,\n       email_service: web::Data<EmailService>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para verificar sa√∫de de todos os componentes\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 120,
    "title": "M√©tricas detalhadas",
    "description": "Expor dados de performance",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct SystemMetrics {\n       pub cpu_usage: f64,\n       pub memory_usage: f64,\n       pub active_connections: u32,\n       pub request_rate: f64,\n       pub average_response_time: f64,\n       pub error_rate: f64,\n       pub db_pool_stats: DbPoolStats,\n   }\n   \n   pub async fn get_metrics(\n       pool: web::Data<DbPool>,\n       _req: HttpRequest,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para coletar e retornar m√©tricas\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "cache"
    ],
    "context": "Controllers"
  },
  {
    "id": 121,
    "title": "Manuten√ß√£o programada",
    "description": "Informar sobre janelas de manuten√ß√£o",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct MaintenanceWindow {\n       pub id: String,\n       pub start_time: DateTime<Utc>,\n       pub end_time: DateTime<Utc>,\n       pub description: String,\n       pub affected_services: Vec<String>,\n       pub status: MaintenanceStatus,\n   }\n   \n   pub async fn get_maintenance_schedule(\n       _req: HttpRequest,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para retornar informa√ß√µes de manuten√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 122,
    "title": "Verifica√ß√£o de seguran√ßa",
    "description": "Avaliar status de seguran√ßa",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct SecurityStatus {\n       pub last_security_scan: DateTime<Utc>,\n       pub open_vulnerabilities: u32,\n       pub certificate_expiry: DateTime<Utc>,\n       pub firewall_status: String,\n       pub updates_available: bool,\n   }\n   \n   pub async fn security_health_check(\n       _req: HttpRequest,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para verificar status de seguran√ßa (admin only)\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa"
    ],
    "context": "Controllers"
  },
  {
    "id": 123,
    "title": "Status personalizado",
    "description": "P√°gina de status p√∫blica",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn status_page(\n       pool: web::Data<DbPool>,\n       template: web::Data<Handlebars>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para gerar p√°gina HTML de status\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub struct StatusPageData {\n       pub system_status: HealthStatus,\n       pub last_updated: String,\n       pub services: Vec<ServiceStatus>,\n       pub incidents: Vec<Incident>,\n       pub uptime_percentage: f64,\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 124,
    "title": "Detec√ß√£o de anomalias",
    "description": "Identificar uso suspeito",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct DeviceAnomalyReport {\n       pub user_id: String,\n       pub device_id: String,\n       pub anomaly_type: AnomalyType,\n       pub confidence: f64,\n       pub detected_at: DateTime<Utc>,\n       pub context: HashMap<String, String>,\n   }\n   \n   #[derive(Debug, Serialize, Deserialize)]\n   pub enum AnomalyType {\n       UnusualLocation,\n       UnexpectedLoginTime,\n       RapidGeoMovement,\n       MultipleFailedAttempts,\n       UnusualBehavior,\n   }\n   \n   pub async fn detect_device_anomalies(\n       pool: web::Data<DbPool>,\n       user_id: web::Path<String>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para detectar anomalias nos dispositivos do usu√°rio\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 125,
    "title": "Nome e √≠cone para dispositivos",
    "description": "Melhorar reconhecimento",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize, Validate)]\n   pub struct DeviceCustomizationRequest {\n       #[validate(length(min = 1, max = 50))]\n       pub display_name: String,\n       pub icon_type: DeviceIconType,\n       pub color: Option<String>,\n   }\n   \n   #[derive(Debug, Serialize, Deserialize)]\n   pub enum DeviceIconType {\n       Desktop,\n       Laptop,\n       Phone,\n       Tablet,\n       Watch,\n       TV,\n       Other,\n   }\n   \n   pub async fn customize_device(\n       pool: web::Data<DbPool>,\n       device_id: web::Path<String>,\n       request: web::Json<DeviceCustomizationRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para personalizar dispositivo\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 126,
    "title": "Notifica√ß√µes de login",
    "description": "Alertar sobre novos dispositivos",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct LoginNotification {\n       pub device_info: DeviceInfo,\n       pub location: Option<LocationInfo>,\n       pub login_time: DateTime<Utc>,\n       pub ip_address: String,\n   }\n   \n   pub async fn send_new_device_notification(\n       pool: &DbPool,\n       user_id: &str,\n       device_id: &str,\n       email_service: &EmailService,\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o para enviar notifica√ß√£o quando um novo dispositivo faz login\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "log",
      "auth"
    ],
    "context": "Controllers"
  },
  {
    "id": 127,
    "title": "Aprova√ß√£o de dispositivos",
    "description": "Verifica√ß√£o em dois passos para novos dispositivos",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct DeviceApprovalRequest {\n       pub device_id: String,\n       pub approval_token: String,\n       pub user_id: String,\n       pub expires_at: DateTime<Utc>,\n   }\n   \n   pub async fn request_device_approval(\n       pool: web::Data<DbPool>,\n       device_id: web::Path<String>,\n       claims: web::ReqData<TokenClaims>,\n       email_service: web::Data<EmailService>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para solicitar aprova√ß√£o de dispositivo\n   }\n   \n   pub async fn approve_device(\n       pool: web::Data<DbPool>,\n       token: web::Path<String>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para aprovar dispositivo via link de email\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 128,
    "title": "Sincroniza√ß√£o entre dispositivos",
    "description": "Notifica√ß√µes instant√¢neas",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct DeviceNotification {\n       pub id: String,\n       pub user_id: String,\n       pub title: String,\n       pub body: String,\n       pub action: Option<NotificationAction>,\n       pub created_at: DateTime<Utc>,\n       pub expires_at: Option<DateTime<Utc>>,\n       pub priority: NotificationPriority,\n   }\n   \n   pub async fn send_notification_to_devices(\n       pool: web::Data<DbPool>,\n       notification: web::Json<DeviceNotification>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para enviar notifica√ß√£o para todos os dispositivos\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 129,
    "title": "An√°lise de for√ßa das respostas",
    "description": "Evitar respostas √≥bvias",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "fn evaluate_answer_strength(question_id: &str, answer: &str) -> AnswerStrength {\n       // Implementa√ß√£o para avaliar quanto uma resposta √© previs√≠vel para a pergunta\n       \n       let answer_length = answer.len();\n       let contains_numbers = answer.chars().any(|c| c.is_numeric());\n       let common_answer = check_common_answer(question_id, answer);\n       \n       if common_answer {\n           return AnswerStrength::Weak;\n       }\n       \n       if answer_length < 5 || !contains_numbers {\n           return AnswerStrength::Medium;\n       }\n       \n       AnswerStrength::Strong\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub enum AnswerStrength {\n       Weak,\n       Medium,\n       Strong,\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "risk"
    ],
    "context": "Controllers"
  },
  {
    "id": 130,
    "title": "Perguntas personalizadas",
    "description": "Permitir perguntas definidas pelo usu√°rio",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize, Validate)]\n   pub struct CustomSecurityQuestionRequest {\n       #[validate(length(min = 10, max = 200))]\n       pub question_text: String,\n       #[validate(length(min = 3, max = 100))]\n       pub answer: String,\n       pub hint: Option<String>,\n   }\n   \n   pub async fn add_custom_security_question(\n       pool: web::Data<DbPool>,\n       request: web::Json<CustomSecurityQuestionRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para adicionar pergunta personalizada\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "user"
    ],
    "context": "Controllers"
  },
  {
    "id": 131,
    "title": "Rota√ß√£o de perguntas",
    "description": "Exigir atualiza√ß√£o peri√≥dica",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub struct SecurityQuestionPolicy {\n       pub min_questions_required: u32,\n       pub rotation_interval_days: u32,\n       pub prevent_reuse: bool,\n       pub min_answer_length: u32,\n   }\n   \n   pub async fn check_questions_expiry(\n       pool: web::Data<DbPool>,\n       user_id: web::Path<String>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para verificar se √© necess√°rio atualizar perguntas\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 132,
    "title": "Verifica√ß√£o progressiva",
    "description": "Aumentar quantidade de perguntas com base no risco",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn get_verification_questions(\n       pool: web::Data<DbPool>,\n       user_email: web::Json<EmailDto>,\n       risk_score: Option<web::Query<u32>>,\n   ) -> Result<HttpResponse, ApiError> {\n       let risk = risk_score.map(|r| r.into_inner()).unwrap_or(0);\n       \n       // N√∫mero de perguntas baseado no n√≠vel de risco\n       let questions_count = match risk {\n           0..=20 => 1, // Baixo risco\n           21..=60 => 2, // M√©dio risco\n           _ => 3,       // Alto risco\n       };\n       \n       // Implementa√ß√£o para selecionar perguntas para verifica√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "risk"
    ],
    "context": "Controllers"
  },
  {
    "id": 133,
    "title": "Dicas visuais",
    "description": "Adicionar imagens para mem√≥ria",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct VisualSecurityQuestion {\n       pub id: String,\n       pub user_id: String,\n       pub image_type: VisualQuestionType,\n       pub correct_answer: String, // Hash da resposta\n       pub created_at: DateTime<Utc>,\n   }\n   \n   #[derive(Debug, Serialize, Deserialize)]\n   pub enum VisualQuestionType {\n       PatternSelect,\n       ImageSequence,\n       ColorChoices,\n       ImageRecognition,\n   }\n   \n   pub async fn setup_visual_security_question(\n       pool: web::Data<DbPool>,\n       request: web::Json<SetupVisualQuestionRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para configurar pergunta visual\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 134,
    "title": "Rota√ß√£o autom√°tica de chaves",
    "description": "Implementar gerenciamento de chaves",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub struct JwtKeyManager {\n       pub current_key: String,\n       pub previous_keys: Vec<String>,\n       pub current_kid: String,\n       pub key_rotation_date: DateTime<Utc>,\n       pub rotation_interval_days: u32,\n   }\n   \n   impl JwtKeyManager {\n       pub fn new(initial_key: String, rotation_interval_days: u32) -> Self {\n           let current_kid = Uuid::new_v4().to_string();\n           Self {\n               current_key: initial_key,\n               previous_keys: Vec::new(),\n               current_kid,\n               key_rotation_date: Utc::now(),\n               rotation_interval_days,\n           }\n       }\n       \n       pub fn rotate_if_needed(&mut self) -> bool {\n           let now = Utc::now();\n           let rotation_duration = Duration::days(self.rotation_interval_days as i64);\n           \n           if now > self.key_rotation_date + rotation_duration {\n               self.rotate_key();\n               return true;\n           }\n           \n           false\n       }\n       \n       fn rotate_key(&mut self) {\n           let new_key = generate_secure_key();\n           let new_kid = Uuid::new_v4().to_string();\n           \n           // Guardar chave anterior\n           self.previous_keys.push(self.current_key.clone());\n           \n           // Limitar n√∫mero de chaves antigas armazenadas\n           if self.previous_keys.len() > 5 {\n               self.previous_keys.remove(0);\n           }\n           \n           // Atualizar chave atual\n           self.current_key = new_key;\n           self.current_kid = new_kid;\n           self.key_rotation_date = Utc::now();\n       }\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 135,
    "title": "Suporte a JWK",
    "description": "Disponibilizar chaves para verifica√ß√£o",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct Jwk {\n       pub kid: String,\n       pub kty: String,\n       pub alg: String,\n       pub use_field: String,\n       pub n: String,\n       pub e: String,\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub struct JwkSet {\n       pub keys: Vec<Jwk>,\n   }\n   \n   pub fn get_public_jwks() -> JwkSet {\n       // Implementa√ß√£o para gerar JWK Set a partir das chaves p√∫blicas\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 136,
    "title": "Verifica√ß√£o de blacklist",
    "description": "Checar tokens revogados",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub struct TokenBlacklist {\n       blacklisted: Arc<RwLock<HashMap<String, DateTime<Utc>>>>,\n   }\n   \n   impl TokenBlacklist {\n       pub fn new() -> Self {\n           Self {\n               blacklisted: Arc::new(RwLock::new(HashMap::new())),\n           }\n       }\n       \n       pub fn add(&self, token_id: String, expiry: DateTime<Utc>) {\n           let mut map = self.blacklisted.write().unwrap();\n           map.insert(token_id, expiry);\n       }\n       \n       pub fn is_blacklisted(&self, token_id: &str) -> bool {\n           let map = self.blacklisted.read().unwrap();\n           map.contains_key(token_id)\n       }\n       \n       pub fn clean_expired(&self) -> usize {\n           let now = Utc::now();\n           let mut map = self.blacklisted.write().unwrap();\n           let initial_size = map.len();\n           \n           map.retain(|_, expiry| *expiry > now);\n           \n           initial_size - map.len()\n       }\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "jwt"
    ],
    "context": "Utils"
  },
  {
    "id": 137,
    "title": "Token com uso √∫nico",
    "description": "Implementar nonce para JWT",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct NonceTokenClaims {\n       pub sub: String,\n       pub exp: i64,\n       pub iat: i64,\n       pub nonce: String,\n   }\n   \n   pub fn generate_nonce_token(\n       user_id: &str, \n       expiration_minutes: i64, \n       secret: &str,\n       nonce_store: &NonceStore,\n   ) -> Result<String, ApiError> {\n       let now = Utc::now();\n       let expiry = now + Duration::minutes(expiration_minutes);\n       let nonce = Uuid::new_v4().to_string();\n       \n       // Salvar nonce no store\n       nonce_store.add_nonce(&nonce, expiry);\n       \n       let claims = NonceTokenClaims {\n           sub: user_id.to_string(),\n           exp: expiry.timestamp(),\n           iat: now.timestamp(),\n           nonce,\n       };\n       \n       // Resto da implementa√ß√£o para gerar o token\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "jwt"
    ],
    "context": "Utils"
  },
  {
    "id": 138,
    "title": "Verifica√ß√£o peri√≥dica de integridade",
    "description": "Garantir consist√™ncia",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "pub struct DbHealthMonitor {\n       check_interval: Duration,\n       last_check: Mutex<DateTime<Utc>>,\n       health_status: RwLock<DbHealthStatus>,\n   }\n   \n   #[derive(Debug, Clone, Serialize)]\n   pub struct DbHealthStatus {\n       pub status: HealthLevel,\n       pub last_checked_at: DateTime<Utc>,\n       pub response_time_ms: u64,\n       pub connection_count: u32,\n       pub error_message: Option<String>,\n   }\n   \n   impl DbHealthMonitor {\n       pub fn new(check_interval_secs: u64) -> Self {\n           Self {\n               check_interval: Duration::seconds(check_interval_secs as i64),\n               last_check: Mutex::new(Utc::now()),\n               health_status: RwLock::new(DbHealthStatus {\n                   status: HealthLevel::Unknown,\n                   last_checked_at: Utc::now(),\n                   response_time_ms: 0,\n                   connection_count: 0,\n                   error_message: None,\n               }),\n           }\n       }\n       \n       pub async fn start_monitoring(self: Arc<Self>, pool: DbPool) {\n           tokio::spawn(async move {\n               loop {\n                   self.perform_health_check(&pool).await;\n                   tokio::time::sleep(self.check_interval.to_std().unwrap()).await;\n               }\n           });\n       }\n       \n       async fn perform_health_check(&self, pool: &DbPool) {\n           // Implementa√ß√£o para verificar sa√∫de do banco de dados\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 139,
    "title": "M√©tricas de pool de conex√£o",
    "description": "Monitorar utiliza√ß√£o",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "#[derive(Debug, Clone, Serialize)]\n   pub struct DbPoolMetrics {\n       pub available_connections: u32,\n       pub used_connections: u32,\n       pub max_connections: u32,\n       pub usage_percentage: f64,\n       pub wait_count: u64,\n       pub max_wait_time_ms: u64,\n       pub avg_wait_time_ms: f64,\n       pub recorded_at: DateTime<Utc>,\n   }\n   \n   pub fn collect_pool_metrics(pool: &DbPool) -> DbPoolMetrics {\n       let state = pool.state();\n       \n       DbPoolMetrics {\n           available_connections: state.idle_connections as u32,\n           used_connections: state.connections - state.idle_connections as u32,\n           max_connections: pool.max_size() as u32,\n           usage_percentage: (state.connections as f64 - state.idle_connections as f64) \n               / pool.max_size() as f64 * 100.0,\n           wait_count: 0, // Obter de estat√≠sticas reais\n           max_wait_time_ms: 0, // Obter de estat√≠sticas reais\n           avg_wait_time_ms: 0.0, // Obter de estat√≠sticas reais\n           recorded_at: Utc::now(),\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db",
      "monitoring"
    ],
    "context": "Db"
  },
  {
    "id": 140,
    "title": "Janela de manuten√ß√£o automatizada",
    "description": "Executar opera√ß√µes de manuten√ß√£o",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "pub struct DbMaintenance {\n       maintenance_tasks: Vec<MaintenanceTask>,\n       schedule: MaintenanceSchedule,\n   }\n   \n   #[derive(Debug, Clone)]\n   pub struct MaintenanceTask {\n       pub name: String,\n       pub sql: String,\n       pub priority: MaintenancePriority,\n       pub estimated_duration_secs: u64,\n   }\n   \n   impl DbMaintenance {\n       pub fn new() -> Self {\n           Self {\n               maintenance_tasks: vec![\n                   MaintenanceTask {\n                       name: \"VACUUM\".to_string(),\n                       sql: \"VACUUM\".to_string(),\n                       priority: MaintenancePriority::High,\n                       estimated_duration_secs: 60,\n                   },\n                   MaintenanceTask {\n                       name: \"ANALYZE\".to_string(),\n                       sql: \"ANALYZE\".to_string(),\n                       priority: MaintenancePriority::Medium,\n                       estimated_duration_secs: 30,\n                   },\n                   // Outras tarefas...\n               ],\n               schedule: MaintenanceSchedule::Daily { hour: 3, minute: 30 },\n           }\n       }\n       \n       pub async fn start_scheduled_maintenance(self, pool: DbPool) {\n           tokio::spawn(async move {\n               loop {\n                   let sleep_duration = self.calculate_next_run();\n                   tokio::time::sleep(sleep_duration).await;\n                   self.perform_maintenance(&pool).await;\n               }\n           });\n       }\n       \n       async fn perform_maintenance(&self, pool: &DbPool) {\n           // Implementa√ß√£o para executar tarefas de manuten√ß√£o\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 141,
    "title": "Backup autom√°tico",
    "description": "Implementar rotina de backup",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "pub struct DbBackupManager {\n       backup_dir: PathBuf,\n       retention_days: u32,\n       schedule: BackupSchedule,\n   }\n   \n   #[derive(Debug, Clone)]\n   pub enum BackupSchedule {\n       Hourly,\n       Daily { hour: u8, minute: u8 },\n       Weekly { day: u8, hour: u8, minute: u8 },\n   }\n   \n   impl DbBackupManager {\n       pub fn new<P: AsRef<Path>>(\n           backup_dir: P,\n           retention_days: u32,\n           schedule: BackupSchedule,\n       ) -> Self {\n           Self {\n               backup_dir: backup_dir.as_ref().to_path_buf(),\n               retention_days,\n               schedule,\n           }\n       }\n       \n       pub async fn start_scheduled_backups(self, db_path: String) {\n           tokio::spawn(async move {\n               loop {\n                   let sleep_duration = self.calculate_next_run();\n                   tokio::time::sleep(sleep_duration).await;\n                   self.perform_backup(&db_path).await;\n                   self.cleanup_old_backups().await;\n               }\n           });\n       }\n       \n       async fn perform_backup(&self, db_path: &str) -> Result<PathBuf, ApiError> {\n           // Implementa√ß√£o para criar backup do banco\n       }\n       \n       async fn cleanup_old_backups(&self) -> Result<usize, ApiError> {\n           // Implementa√ß√£o para remover backups antigos\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db",
      "backup"
    ],
    "context": "Db"
  },
  {
    "id": 142,
    "title": "Conex√µes com tempo de vida",
    "description": "Renovar conex√µes periodicamente",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "pub struct DbConnectionManager {\n       pool: DbPool,\n       connection_ttl: Duration,\n   }\n   \n   impl DbConnectionManager {\n       pub fn new(pool: DbPool, connection_ttl_hours: u64) -> Self {\n           Self {\n               pool,\n               connection_ttl: Duration::hours(connection_ttl_hours as i64),\n           }\n       }\n       \n       pub async fn start_connection_renewal(self: Arc<Self>) {\n           tokio::spawn(async move {\n               loop {\n                   tokio::time::sleep(std::time::Duration::from_secs(3600)).await; // A cada hora\n                   self.renew_connections().await;\n               }\n           });\n       }\n       \n       async fn renew_connections(&self) -> Result<usize, ApiError> {\n           // Implementa√ß√£o para renovar conex√µes antigas\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 143,
    "title": "Adicionar documenta√ß√£o",
    "description": "Incluir um coment√°rio principal explicando o prop√≥sito da biblioteca",
    "priority": "baixa",
    "category": "Lib.rs",
    "code_example": "//! Rust Auth API - Uma biblioteca de autentica√ß√£o completa usando Actix-web e SQLite.\n   //! \n   //! Esta biblioteca oferece funcionalidades de autentica√ß√£o, autoriza√ß√£o e gerenciamento\n   //! de usu√°rios para aplica√ß√µes web seguras.",
    "status": "pendente",
    "tags": [
      "lib.rs",
      "ui"
    ],
    "context": "Lib.rs"
  },
  {
    "id": 144,
    "title": "Sanitiza√ß√£o de mensagens de erro",
    "description": "Implementar sanitiza√ß√£o para n√£o expor detalhes sens√≠veis em ambientes de produ√ß√£o",
    "priority": "alta",
    "category": "Errors",
    "code_example": "fn sanitize_error_message(message: &str, is_production: bool) -> String {\n       if is_production && message.contains(\"senha\") {\n           return \"Erro interno durante processamento de credenciais\".to_string();\n       }\n       message.to_string()\n   }",
    "status": "pendente",
    "tags": [
      "errors"
    ],
    "context": "Errors"
  },
  {
    "id": 145,
    "title": "Implementar graceful shutdown",
    "description": "- Adicionar tratamento para sinais SIGTERM e SIGINT para desligar o servidor de forma segura:",
    "priority": "alta",
    "category": "Main.rs",
    "code_example": "let (tx, rx) = tokio::sync::mpsc::channel(1);\n   ctrlc::set_handler(move || {\n       tx.try_send(()).ok();\n   }).expect(\"Error setting Ctrl-C handler\");",
    "status": "pendente",
    "tags": [
      "main.rs"
    ],
    "context": "Main.rs"
  },
  {
    "id": 146,
    "title": "Configura√ß√£o de TLS",
    "description": "- Adicionar suporte a HTTPS em produ√ß√£o:",
    "priority": "m√©dia",
    "category": "Main.rs",
    "code_example": ".bind_rustls(format!(\"{}:{}\", config.server.host, config.server.port), rustls_config)?",
    "status": "pendente",
    "tags": [
      "main.rs",
      "config"
    ],
    "context": "Main.rs"
  },
  {
    "id": 147,
    "title": "Limita√ß√£o de conex√µes",
    "description": "- Configurar limites de conex√µes m√°ximas:",
    "priority": "baixa",
    "category": "Main.rs",
    "code_example": "HttpServer::new(move || { ... })\n      .workers(config.server.workers)\n      .max_connections(config.server.max_connections)",
    "status": "pendente",
    "tags": [
      "main.rs",
      "config",
      "rate-limit"
    ],
    "context": "Main.rs"
  },
  {
    "id": 148,
    "title": "Telemetria",
    "description": "- Integrar com algum sistema de monitoramento como Prometheus:",
    "priority": "m√©dia",
    "category": "Main.rs",
    "code_example": ".app_data(web::Data::new(metrics_registry.clone()))\n   .route(\"/metrics\", web::get().to(metrics_handler))",
    "status": "pendente",
    "tags": [
      "main.rs",
      "log",
      "monitoring"
    ],
    "context": "Main.rs"
  },
  {
    "id": 149,
    "title": "Extra√ß√£o de configura√ß√µes",
    "description": "- Extrair a configura√ß√£o do servidor HTTP para uma fun√ß√£o separada para melhorar a legibilidade.\n\n### `src/lib.rs`\n\n**An√°lise:**\n- ‚úÖ Exporta√ß√£o adequada de m√≥dulos\n- ‚úÖ C√≥digo limpo e organizado\n- ‚úÖ Coment√°rios √∫teis\n\n**Melhorias Sugeridas:**\n1. üìù **Adicionar documenta√ß√£o** - Incluir um coment√°rio principal explicando o prop√≥sito da biblioteca:",
    "priority": "baixa",
    "category": "Main.rs",
    "code_example": "//! Rust Auth API - Uma biblioteca de autentica√ß√£o completa usando Actix-web e SQLite.\n   //! \n   //! Esta biblioteca oferece funcionalidades de autentica√ß√£o, autoriza√ß√£o e gerenciamento\n   //! de usu√°rios para aplica√ß√µes web seguras.",
    "status": "pendente",
    "tags": [
      "main.rs",
      "ui",
      "config",
      "risk"
    ],
    "context": "Main.rs"
  },
  {
    "id": 150,
    "title": "Adicionar metadados de crate",
    "description": "- No Cargo.toml, adicionar:\n   ```toml\n   authors = [\"Seu Nome <seu.email@exemplo.com>\"]\n   repository = \"https://github.com/seu-usuario/rust-auth-api\"\n   documentation = \"https://docs.rs/rust-auth-api\"\n   readme = \"README.md\"\n   ```\n\n3. üìù **Adicionar testes de integra√ß√£o** - Criar uma pasta tests/ na raiz com testes de integra√ß√£o para API.\n\n4. üìù **Incluir vers√£o e registro** - Adicionar constantes de vers√£o para facilitar o rastreamento:",
    "priority": "baixa",
    "category": "Lib.rs",
    "code_example": "pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n   pub const BUILD_TIME: &str = env!(\"BUILD_TIMESTAMP\"); // Requer script de build",
    "status": "pendente",
    "tags": [
      "lib.rs",
      "test",
      "api",
      "ui",
      "auth",
      "email",
      "rate-limit"
    ],
    "context": "Lib.rs"
  },
  {
    "id": 151,
    "title": "Valida√ß√£o de configura√ß√µes cr√≠ticas",
    "description": "- Adicionar valida√ß√µes expl√≠citas para valores cr√≠ticos:",
    "priority": "alta",
    "category": "Config",
    "code_example": "fn validate_config(&self) -> Result<(), String> {\n       if self.jwt.secret.len() < 32 {\n           return Err(\"JWT secret muito curto, deve ter pelo menos 32 caracteres\".to_string());\n       }\n       // Mais valida√ß√µes...\n       Ok(())\n   }",
    "status": "pendente",
    "tags": [
      "config"
    ],
    "context": "Config"
  },
  {
    "id": 152,
    "title": "Suporte a arquivos de configura√ß√£o",
    "description": "- Adicionar suporte para carregar configura√ß√µes de arquivos YAML/TOML/JSON al√©m de vari√°veis de ambiente:",
    "priority": "m√©dia",
    "category": "Config",
    "code_example": "pub fn from_file(path: &str) -> Result<Self, ConfigError> {\n       let file = std::fs::File::open(path)?;\n       let config: Config = serde_yaml::from_reader(file)?;\n       Ok(config)\n   }",
    "status": "pendente",
    "tags": [
      "config",
      "ui"
    ],
    "context": "Config"
  },
  {
    "id": 153,
    "title": "Configura√ß√µes por ambiente",
    "description": "- Implementar carregamento condicional baseado em ambiente:",
    "priority": "baixa",
    "category": "Config",
    "code_example": "let env = std::env::var(\"ENVIRONMENT\").unwrap_or_else(|_| \"development\".to_string());\n   let config_path = format!(\"config/{}.yaml\", env);",
    "status": "pendente",
    "tags": [
      "config"
    ],
    "context": "Config"
  },
  {
    "id": 154,
    "title": "Mascaramento de segredos",
    "description": "- Implementar mascaramento para logs de valores sens√≠veis:",
    "priority": "alta",
    "category": "Config",
    "code_example": "impl std::fmt::Display for JwtConfig {\n       fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n           write!(f, \"JwtConfig {{ secret: \\\"****\\\", expiration: {} }}\", self.expiration)\n       }\n   }",
    "status": "pendente",
    "tags": [
      "config",
      "log"
    ],
    "context": "Config"
  },
  {
    "id": 155,
    "title": "Cache de configura√ß√£o",
    "description": "- Implementar cache para configura√ß√µes que s√£o acessadas frequentemente:",
    "priority": "m√©dia",
    "category": "Config",
    "code_example": "pub fn get_instance() -> Arc<Config> {\n       static INSTANCE: OnceCell<Arc<Config>> = OnceCell::new();\n       INSTANCE.get_or_init(|| {\n           Arc::new(Config::from_env().expect(\"Failed to load config\"))\n       }).clone()\n   }",
    "status": "pendente",
    "tags": [
      "config",
      "cache"
    ],
    "context": "Config"
  },
  {
    "id": 156,
    "title": "Documenta√ß√£o detalhada",
    "description": "- Adicionar documenta√ß√£o detalhada para cada campo de configura√ß√£o:\n   ```rust\n   /// Configura√ß√£o do servidor web\n   /// \n   /// # Campos\n   /// \n   /// * `host` - Endere√ßo IP para vincular o servidor HTTP\n   /// * `port` - Porta para vincular o servidor HTTP\n   /// * `workers` - N√∫mero de workers para processar requisi√ß√µes (padr√£o: n√∫cleos l√≥gicos)\n   #[derive(Debug, Deserialize, Clone)]\n   pub struct ServerConfig { /*...*/ }\n   ```\n\n### `src/errors/mod.rs`\n\n**An√°lise:**\n- ‚úÖ Uso adequado da biblioteca thiserror para defini√ß√£o de erros\n- ‚úÖ Boa estrutura de mapeamento de erros para respostas HTTP\n- ‚úÖ Implementa√ß√£o adequada de convers√£o de erros de bibliotecas externas\n- ‚úÖ Suporte a erros de valida√ß√£o com detalhes estruturados\n- ‚úÖ Logging adequado de erros\n\n**Melhorias Sugeridas:**\n1. üîí **Sanitiza√ß√£o de mensagens de erro** - Implementar sanitiza√ß√£o para n√£o expor detalhes sens√≠veis em ambientes de produ√ß√£o:",
    "priority": "baixa",
    "category": "Config",
    "code_example": "fn sanitize_error_message(message: &str, is_production: bool) -> String {\n       if is_production && message.contains(\"senha\") {\n           return \"Erro interno durante processamento de credenciais\".to_string();\n       }\n       message.to_string()\n   }",
    "status": "pendente",
    "tags": [
      "config",
      "log",
      "ui",
      "risk"
    ],
    "context": "Config"
  },
  {
    "id": 157,
    "title": "C√≥digos de erro mais descritivos",
    "description": "- Implementar c√≥digos de erro padronizados e mais espec√≠ficos:",
    "priority": "baixa",
    "category": "Errors",
    "code_example": "pub enum ErrorCode {\n       AuthInvalidCredentials = 1001,\n       AuthTokenExpired = 1002,\n       AuthTokenInvalid = 1003,\n       ValidationFailure = 2001,\n       // etc.\n   }",
    "status": "pendente",
    "tags": [
      "errors"
    ],
    "context": "Errors"
  },
  {
    "id": 158,
    "title": "Internacionaliza√ß√£o de mensagens de erro",
    "description": "- Adicionar suporte para mensagens de erro em m√∫ltiplos idiomas:",
    "priority": "m√©dia",
    "category": "Errors",
    "code_example": "pub fn localized_message(&self, lang: &str) -> String {\n       let key = match self {\n           ApiError::AuthenticationError(_) => \"error.auth.failed\",\n           // etc.\n       };\n       i18n::translate(key, lang)\n   }",
    "status": "pendente",
    "tags": [
      "errors"
    ],
    "context": "Errors"
  },
  {
    "id": 159,
    "title": "Documenta√ß√£o de erros para API",
    "description": "- Gerar documenta√ß√£o OpenAPI para os erros da API:",
    "priority": "baixa",
    "category": "Errors",
    "code_example": "/// Erro retornado quando um usu√°rio n√£o est√° autorizado a acessar um recurso.\n   /// \n   /// Status: 403 Forbidden\n   #[derive(Error, Debug)]\n   #[error(\"Erro de autoriza√ß√£o: {0}\")]\n   pub struct AuthorizationError(pub String);",
    "status": "pendente",
    "tags": [
      "errors",
      "api"
    ],
    "context": "Errors"
  },
  {
    "id": 160,
    "title": "Unifica√ß√£o de erros duplicados",
    "description": "- Remover redund√¢ncias como `BadRequestError`/`BadRequest` e `NotFoundError`/`NotFound`:",
    "priority": "baixa",
    "category": "Errors",
    "code_example": "#[error(\"Requisi√ß√£o inv√°lida: {0}\")]\n   BadRequest(String),  // Manter apenas esta vers√£o",
    "status": "pendente",
    "tags": [
      "errors"
    ],
    "context": "Errors"
  },
  {
    "id": 161,
    "title": "Implementar recovery de panic",
    "description": "- Adicionar middleware para capturar panics e convert√™-los em erros 500:",
    "priority": "m√©dia",
    "category": "Errors",
    "code_example": "pub fn capture_panic(info: &PanicInfo) -> HttpResponse {\n       let error = ApiError::InternalServerError(\"Ocorreu um erro interno inesperado\".to_string());\n       error.error_response()\n   }",
    "status": "pendente",
    "tags": [
      "errors",
      "recovery"
    ],
    "context": "Errors"
  },
  {
    "id": 162,
    "title": "Parametriza√ß√£o de configura√ß√µes de pool",
    "description": "- Tornar os par√¢metros do pool configur√°veis:",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "let pool = Pool::builder()\n       .max_size(config.database.max_connections)\n       .min_idle(Some(config.database.min_connections))\n       .idle_timeout(Some(Duration::from_secs(config.database.idle_timeout)))\n       .build(manager)?;",
    "status": "pendente",
    "tags": [
      "db",
      "config"
    ],
    "context": "Db"
  },
  {
    "id": 163,
    "title": "Valida√ß√£o de integridade do banco",
    "description": "- Adicionar uma verifica√ß√£o de integridade no startup:",
    "priority": "alta",
    "category": "Db",
    "code_example": "fn validate_db_integrity(conn: &Connection) -> Result<(), ApiError> {\n       let integrity_check: String = conn.query_row(\"PRAGMA integrity_check\", [], |row| row.get(0))?;\n       if integrity_check != \"ok\" {\n           return Err(ApiError::DatabaseError(format!(\"Falha na verifica√ß√£o de integridade: {}\", integrity_check)));\n       }\n       Ok(())\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 164,
    "title": "Logs de m√©tricas de pool",
    "description": "- Adicionar logs peri√≥dicos de m√©tricas do pool:",
    "priority": "baixa",
    "category": "Db",
    "code_example": "fn log_pool_metrics(pool: &DbPool) {\n       let state = pool.state();\n       info!(\"Pool DB: conex√µes={}, em_uso={}, idle={}\",\n             state.connections, state.in_use, state.idle);\n   }",
    "status": "pendente",
    "tags": [
      "db",
      "log"
    ],
    "context": "Db"
  },
  {
    "id": 165,
    "title": "Backup autom√°tico",
    "description": "- Implementar um mecanismo de backup autom√°tico:",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "fn backup_database(db_path: &str, backup_dir: &str) -> Result<(), ApiError> {\n       let timestamp = chrono::Utc::now().format(\"%Y%m%d_%H%M%S\");\n       let backup_path = format!(\"{}/backup_{}.db\", backup_dir, timestamp);\n       let conn = Connection::open(db_path)?;\n       let backup = Connection::open(&backup_path)?;\n       conn.backup(rusqlite::DatabaseName::Main, &backup, None)?;\n       Ok(())\n   }",
    "status": "pendente",
    "tags": [
      "db",
      "backup"
    ],
    "context": "Db"
  },
  {
    "id": 166,
    "title": "Roteamento de conex√µes",
    "description": "- Implementar um roteador de conex√µes para separar leitura/escrita:",
    "priority": "alta",
    "category": "Db",
    "code_example": "pub enum DbAccessType {\n       ReadOnly,\n       ReadWrite,\n   }\n   \n   pub fn get_connection(pool: &DbPool, access_type: DbAccessType) -> Result<DbConnection, ApiError> {\n       let conn = pool.get()?;\n       match access_type {\n           DbAccessType::ReadOnly => {\n               conn.execute_batch(\"PRAGMA query_only = ON;\")?;\n           },\n           DbAccessType::ReadWrite => {},\n       }\n       Ok(conn)\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 167,
    "title": "Extens√µes de conex√£o",
    "description": "- Adicionar uma extens√£o para encapsular opera√ß√µes comuns:",
    "priority": "baixa",
    "category": "Db",
    "code_example": "pub trait ConnectionExt {\n       fn with_transaction<T, F>(&mut self, f: F) -> Result<T, ApiError>\n       where F: FnOnce(&rusqlite::Transaction<'_>) -> Result<T, ApiError>;\n   }\n   \n   impl ConnectionExt for rusqlite::Connection {\n       fn with_transaction<T, F>(&mut self, f: F) -> Result<T, ApiError>\n       where F: FnOnce(&rusqlite::Transaction<'_>) -> Result<T, ApiError> {\n           let tx = self.transaction()?;\n           let result = f(&tx);\n           match result {\n               Ok(value) => {\n                   tx.commit()?;\n                   Ok(value)\n               }\n               Err(e) => {\n                   tx.rollback()?;\n                   Err(e)\n               }\n           }\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 168,
    "title": "Rate Limiting por Endpoint",
    "description": "- Implementar limita√ß√£o de taxa por endpoint sens√≠vel:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "#[middleware::rate_limit(per_second = 1, burst = 5)]\n   pub async fn change_password(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "api",
      "rate-limit"
    ],
    "context": "Controllers"
  },
  {
    "id": 169,
    "title": "Documenta√ß√£o OpenAPI",
    "description": "- Adicionar anota√ß√µes OpenAPI para documenta√ß√£o autom√°tica:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "/// Registra um novo usu√°rio no sistema.\n   /// \n   /// Retorna os dados do usu√°rio criado, sem informa√ß√µes sens√≠veis.\n   #[openapi(\n   ///   path = \"/auth/register\",\n   ///   method = \"post\",\n   ///   tags = [\"auth\"],\n   ///   request_body = RegisterDto\n   /// )]\n   pub async fn register(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "api"
    ],
    "context": "Controllers"
  },
  {
    "id": 170,
    "title": "Aplica√ß√£o de pol√≠ticas de seguran√ßa",
    "description": "- Implementar pol√≠ticas de seguran√ßa como CORS e CSP de forma configur√°vel:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub async fn login(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n       let response = HttpResponse::Ok()\n           .insert_header((\"Content-Security-Policy\", config.security.csp_policy.clone()))\n           .json(ApiResponse::success_with_message(auth_response, \"Login realizado com sucesso\"));\n       Ok(response)\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa",
      "config"
    ],
    "context": "Controllers"
  },
  {
    "id": 171,
    "title": "Eventos de auditoria",
    "description": "- Adicionar registro de eventos para a√ß√µes cr√≠ticas:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "pub async fn delete_user(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n       audit_log::record(\n           &pool,\n           \"user.delete\",\n           &claims.sub,\n           AuditData::new()\n               .add(\"target_user_id\", &user_id)\n               .add(\"admin_action\", true)\n       ).await?;\n       // Resto da implementa√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "log",
      "webhook"
    ],
    "context": "Controllers"
  },
  {
    "id": 172,
    "title": "M√©tricas de uso",
    "description": "- Adicionar instrumenta√ß√£o para m√©tricas:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "pub async fn login(...) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o existente\n       metrics::increment_counter!(\"auth_login_total\");\n       metrics::histogram!(\"auth_login_duration_ms\", start.elapsed().as_millis() as f64);\n       // Resto da implementa√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 173,
    "title": "Refatora√ß√£o de valida√ß√µes de autoriza√ß√£o",
    "description": "- Criar um helper para verifica√ß√µes comuns de autoriza√ß√£o:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "fn ensure_authorized(claims: &TokenClaims, user_id: &str, action: &str) -> Result<(), ApiError> {\n       if claims.sub == user_id || claims.is_admin {\n           return Ok(());\n       }\n       Err(ApiError::AuthorizationError(\n           format!(\"Voc√™ n√£o tem permiss√£o para {} este usu√°rio\", action)\n       ))\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 174,
    "title": "Tratamento de consultas grandes",
    "description": "- Implementar pagina√ß√£o com cursor para melhor performance:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(serde::Deserialize)]\n   pub struct CursorPaginatedQuery {\n       pub cursor: Option<String>,\n       pub page_size: Option<u64>,\n       pub order: Option<String>,\n   }\n   \n   pub async fn list_users_cursor(\n       pool: web::Data<DbPool>,\n       query: web::Query<CursorPaginatedQuery>,\n   ) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o com cursor ao inv√©s de offset\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "cache"
    ],
    "context": "Controllers"
  },
  {
    "id": 175,
    "title": "Rota√ß√£o de JWT Key",
    "description": "- Implementar suporte para rota√ß√£o de chaves JWT:",
    "priority": "alta",
    "category": "Middleware",
    "code_example": "struct JwtKeyManager {\n       current_key: String,\n       previous_keys: Vec<String>,\n       rotation_timestamp: DateTime<Utc>,\n   }\n   \n   impl JwtKeyManager {\n       fn validate_token(&self, token: &str) -> Result<TokenClaims, ApiError> {\n           // Tentar a chave atual primeiro\n           match decode_token(token, &self.current_key) {\n               Ok(claims) => return Ok(claims),\n               Err(_) => {\n                   // Tentar chaves antigas\n                   for key in &self.previous_keys {\n                       if let Ok(claims) = decode_token(token, key) {\n                           return Ok(claims);\n                       }\n                   }\n               }\n           }\n           // Se chegou aqui, nenhuma chave funcionou\n           Err(ApiError::AuthenticationError(\"Token inv√°lido\".to_string()))\n       }\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "jwt"
    ],
    "context": "Middleware"
  },
  {
    "id": 176,
    "title": "Inje√ß√£o de depend√™ncia para middleware",
    "description": "- Implementar DI para facilitar testes:",
    "priority": "m√©dia",
    "category": "Middleware",
    "code_example": "pub struct AuthMiddlewareFactory<T: TokenValidator> {\n       validator: Arc<T>,\n   }\n   \n   pub trait TokenValidator: Send + Sync + 'static {\n       fn validate(&self, token: &str) -> Result<TokenClaims, ApiError>;\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "test"
    ],
    "context": "Middleware"
  },
  {
    "id": 177,
    "title": "Configura√ß√£o avan√ßada de CSP",
    "description": "- Adicionar suporte para configura√ß√µes mais detalhadas:",
    "priority": "baixa",
    "category": "Middleware",
    "code_example": "pub struct CspBuilder {\n       directives: HashMap<String, Vec<String>>,\n   }\n   \n   impl CspBuilder {\n       pub fn new() -> Self {\n           let mut builder = Self { directives: HashMap::new() };\n           // Configurar valores padr√£o\n           builder.add_directive(\"default-src\", vec![\"'self'\"]);\n           builder\n       }\n       \n       pub fn add_directive<S: Into<String>>(mut self, name: S, values: Vec<&str>) -> Self {\n           let name = name.into();\n           let values = values.into_iter().map(String::from).collect();\n           self.directives.insert(name, values);\n           self\n       }\n       \n       pub fn build(&self) -> String {\n           // Construir a string CSP\n           self.directives.iter()\n               .map(|(name, values)| format!(\"{} {}\", name, values.join(\" \")))\n               .collect::<Vec<_>>()\n               .join(\"; \")\n       }\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "config"
    ],
    "context": "Middleware"
  },
  {
    "id": 178,
    "title": "Logging de eventos de seguran√ßa",
    "description": "- Adicionar rastreamento para eventos de seguran√ßa importantes:",
    "priority": "alta",
    "category": "Middleware",
    "code_example": "fn record_security_event(\n       req: &ServiceRequest, \n       event_type: &str, \n       details: &str\n   ) {\n       let ip = req.connection_info().realip_remote_addr().unwrap_or(\"unknown\").to_string();\n       let user_agent = req.headers().get(\"User-Agent\")\n           .and_then(|h| h.to_str().ok())\n           .unwrap_or(\"unknown\");\n           \n       info!(\n           event_type = event_type,\n           ip = ip,\n           user_agent = user_agent,\n           details = details,\n           \"Evento de seguran√ßa detectado\"\n       );\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "seguran√ßa",
      "log",
      "webhook"
    ],
    "context": "Middleware"
  },
  {
    "id": 179,
    "title": "Expans√£o do rate limiter",
    "description": "- Adicionar funcionalidades como rate limiting din√¢mico:",
    "priority": "m√©dia",
    "category": "Middleware",
    "code_example": "pub struct DynamicRateLimiter {\n       base_capacity: u32,\n       base_refill_rate: f64,\n       user_factors: Arc<RwLock<HashMap<String, f64>>>,\n   }\n   \n   impl DynamicRateLimiter {\n       pub fn adjust_user_factor(&self, user_id: &str, factor: f64) {\n           let mut factors = self.user_factors.write().unwrap();\n           factors.insert(user_id.to_string(), factor);\n       }\n       \n       pub fn get_limit_for_user(&self, user_id: &str) -> (u32, f64) {\n           let factors = self.user_factors.read().unwrap();\n           let factor = factors.get(user_id).copied().unwrap_or(1.0);\n           \n           let capacity = (self.base_capacity as f64 * factor) as u32;\n           let refill_rate = self.base_refill_rate * factor;\n           \n           (capacity, refill_rate)\n       }\n   }",
    "status": "pendente",
    "tags": [
      "middleware",
      "rate-limit"
    ],
    "context": "Middleware"
  },
  {
    "id": 180,
    "title": "Preven√ß√£o avan√ßada de CSRF",
    "description": "- Implementar verifica√ß√µes de origem (Origin/Referer):",
    "priority": "alta",
    "category": "Middleware",
    "code_example": "fn validate_request_origin(req: &ServiceRequest, allowed_origins: &[String]) -> Result<(), ApiError> {\n       let origin = req.headers().get(\"Origin\").and_then(|h| h.to_str().ok());\n       let referer = req.headers().get(\"Referer\").and_then(|h| h.to_str().ok());\n       \n       match (origin, referer) {\n           (Some(origin), _) if allowed_origins.iter().any(|o| o == origin) => Ok(()),\n           (None, Some(referer)) if allowed_origins.iter().any(|o| referer.starts_with(o)) => Ok(()),\n           _ => Err(ApiError::ForbiddenError(\"Origem inv√°lida\".to_string())),\n       }\n   }",
    "status": "pendente",
    "tags": [
      "middleware"
    ],
    "context": "Middleware"
  },
  {
    "id": 181,
    "title": "Valida√ß√£o de for√ßa de senha",
    "description": "- Adicionar valida√ß√£o direta no DTO:",
    "priority": "alta",
    "category": "Models",
    "code_example": "#[validate(custom = \"validate_password_strength\")]\n   pub password: Option<String>,\n   \n   // Fun√ß√£o auxiliar\n   fn validate_password_strength(password: &str) -> Result<(), ValidationError> {\n       // Implementa√ß√£o aqui\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "password"
    ],
    "context": "Models"
  },
  {
    "id": 182,
    "title": "Documenta√ß√£o OpenAPI",
    "description": "- Adicionar anota√ß√µes para documenta√ß√£o API:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "/// Modelo para senha tempor√°ria\n   /// \n   /// @schema TemporaryPassword\n   #[derive(Debug, Serialize, Deserialize, Clone)]\n   pub struct TemporaryPassword {\n       // campos...\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "api"
    ],
    "context": "Models"
  },
  {
    "id": 183,
    "title": "Timestamp de expira√ß√£o",
    "description": "- Adicionar campo para expira√ß√£o baseada em tempo:",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub expires_at: DateTime<Utc>,\n   \n   // No construtor\n   pub fn new(user_id: String, password_hash: String, usage_limit: i32, expiration_hours: i32) -> Self {\n       let expires_at = Utc::now() + Duration::hours(expiration_hours as i64);\n       Self {\n           // outros campos\n           expires_at,\n       }\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 184,
    "title": "Hist√≥rico de senhas tempor√°rias",
    "description": "- Implementar estruturas para rastrear hist√≥rico:",
    "priority": "alta",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct TemporaryPasswordHistory {\n       pub id: String,\n       pub user_id: String,\n       pub created_at: DateTime<Utc>,\n       pub expired_at: DateTime<Utc>,\n       pub was_used: bool,\n       pub usage_count: i32,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "password"
    ],
    "context": "Models"
  },
  {
    "id": 185,
    "title": "Implementar m√©todo de verifica√ß√£o",
    "description": "- Criar m√©todo para verificar se a senha expirou:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "pub fn is_expired(&self) -> bool {\n       self.expires_at < Utc::now() || self.usage_count >= self.usage_limit\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "password"
    ],
    "context": "Models"
  },
  {
    "id": 186,
    "title": "Limpeza autom√°tica",
    "description": "- Implementar fun√ß√£o para limpar senhas expiradas:",
    "priority": "alta",
    "category": "Repositories",
    "code_example": "pub async fn cleanup_expired_passwords(pool: Arc<DbPool>) -> Result<usize, ApiError> {\n       let conn = pool.get()?;\n       let rows_affected = conn.execute(\n           \"DELETE FROM temporary_passwords WHERE (created_at < datetime('now', '-24 hours') OR usage_count >= usage_limit) AND is_active = TRUE\",\n           params![],\n       )?;\n       Ok(rows_affected)\n   }",
    "status": "pendente",
    "tags": [
      "repositories",
      "password"
    ],
    "context": "Repositories"
  },
  {
    "id": 187,
    "title": "M√©tricas de uso",
    "description": "- Adicionar fun√ß√£o para obter estat√≠sticas:",
    "priority": "baixa",
    "category": "Repositories",
    "code_example": "pub async fn get_usage_stats(pool: Arc<DbPool>) -> Result<TemporaryPasswordStats, ApiError> {\n       // Implementa√ß√£o para obter estat√≠sticas\n   }",
    "status": "pendente",
    "tags": [
      "repositories"
    ],
    "context": "Repositories"
  },
  {
    "id": 188,
    "title": "Pagina√ß√£o",
    "description": "- Implementar fun√ß√µes com suporte a pagina√ß√£o:",
    "priority": "m√©dia",
    "category": "Repositories",
    "code_example": "pub async fn list_with_pagination(\n       pool: Arc<DbPool>, \n       user_id: &str,\n       page: u64,\n       page_size: u64\n   ) -> Result<(Vec<TemporaryPassword>, u64), ApiError> {\n       // Implementa√ß√£o com pagina√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "repositories"
    ],
    "context": "Repositories"
  },
  {
    "id": 189,
    "title": "Notifica√ß√£o de quebra de seguran√ßa",
    "description": "- Adicionar fun√ß√£o para verificar tentativas de uso:",
    "priority": "alta",
    "category": "Repositories",
    "code_example": "pub async fn record_usage_attempt(\n       pool: Arc<DbPool>,\n       temp_password_id: &str,\n       success: bool,\n       ip_address: Option<&str>,\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o para registrar tentativas\n   }",
    "status": "pendente",
    "tags": [
      "repositories",
      "seguran√ßa",
      "email"
    ],
    "context": "Repositories"
  },
  {
    "id": 190,
    "title": "Cache de verifica√ß√£o",
    "description": "- Implementar cache para verifica√ß√µes frequentes:",
    "priority": "baixa",
    "category": "Repositories",
    "code_example": "pub async fn find_with_cache(\n       pool: Arc<DbPool>,\n       cache: &moka::future::Cache<String, TemporaryPassword>,\n       user_id: &str\n   ) -> Result<Option<TemporaryPassword>, ApiError> {\n       // Implementa√ß√£o com cache\n   }",
    "status": "pendente",
    "tags": [
      "repositories",
      "cache"
    ],
    "context": "Repositories"
  },
  {
    "id": 191,
    "title": "Configura√ß√£o din√¢mica",
    "description": "- Permitir ajustes baseados em hardware:",
    "priority": "alta",
    "category": "Utils",
    "code_example": "pub fn configure_params(\n       memory_cost: Option<u32>,\n       time_cost: Option<u32>,\n       parallelism: Option<u32>\n   ) -> Argon2Params {\n       Argon2Params {\n           memory_cost: memory_cost.unwrap_or(DEFAULT_MEMORY_COST),\n           time_cost: time_cost.unwrap_or(DEFAULT_TIME_COST),\n           parallelism: parallelism.unwrap_or(DEFAULT_PARALLELISM),\n       }\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "config"
    ],
    "context": "Utils"
  },
  {
    "id": 192,
    "title": "Logging seguro",
    "description": "- Adicionar logging para eventos de seguran√ßa:",
    "priority": "baixa",
    "category": "Utils",
    "code_example": "pub fn hash_password(password: &str) -> Result<String, String> {\n       // implementa√ß√£o existente\n       tracing::debug!(\"Senha hashada com par√¢metros: m={}, t={}, p={}\", \n           DEFAULT_MEMORY_COST, DEFAULT_TIME_COST, DEFAULT_PARALLELISM);\n       // resto da implementa√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "seguran√ßa",
      "log",
      "webhook"
    ],
    "context": "Utils"
  },
  {
    "id": 193,
    "title": "Detec√ß√£o de ataques",
    "description": "- Adicionar temporizador para mitigar timing attacks:",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn verify_password(password: &str, hash: &str) -> Result<bool, String> {\n       let start = std::time::Instant::now();\n       let result = argon2::verify_encoded(hash, password.as_bytes())\n           .map_err(|e| format!(\"Erro ao verificar senha: {}\", e));\n           \n       // Garantir tempo m√≠nimo para evitar timing attacks\n       let elapsed = start.elapsed();\n       if elapsed < std::time::Duration::from_millis(MIN_VERIFICATION_TIME) {\n           std::thread::sleep(std::time::Duration::from_millis(MIN_VERIFICATION_TIME) - elapsed);\n       }\n       \n       result\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 194,
    "title": "Upgrading de par√¢metros",
    "description": "- Adicionar fun√ß√£o para upgrade de hashes antigos:",
    "priority": "alta",
    "category": "Utils",
    "code_example": "pub fn needs_rehash(hash: &str) -> bool {\n       // Verificar se o hash atual usa par√¢metros inferiores aos atuais\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 195,
    "title": "Salt personalizado",
    "description": "- Permitir uso de salt personalizado:",
    "priority": "baixa",
    "category": "Utils",
    "code_example": "pub fn hash_password_with_salt(password: &str, salt: &[u8]) -> Result<String, String> {\n       // Implementa√ß√£o com salt fornecido\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 196,
    "title": "Rastreamento de IPs e dispositivos",
    "description": "- Adicionar campos para audit trail:",
    "priority": "alta",
    "category": "Models",
    "code_example": "pub last_login_ip: Option<String>,\n   pub last_login_device: Option<String>,\n   pub known_ips: Vec<String>, // Serializado como JSON",
    "status": "pendente",
    "tags": [
      "models",
      "log"
    ],
    "context": "Models"
  },
  {
    "id": 197,
    "title": "M√©tricas de usu√°rio",
    "description": "- Adicionar campos para estat√≠sticas:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "pub login_count: i32,\n   pub last_password_change: Option<DateTime<Utc>>,\n   pub password_history: Vec<PasswordHistoryEntry>, // Para evitar reuso",
    "status": "pendente",
    "tags": [
      "models",
      "user"
    ],
    "context": "Models"
  },
  {
    "id": 198,
    "title": "Status extendido",
    "description": "- Adicionar enum para representar status mais detalhado:",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n   pub enum UserStatus {\n       Active,\n       Inactive,\n       PendingVerification,\n       Suspended,\n       Locked,\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 199,
    "title": "Verifica√ß√£o avan√ßada",
    "description": "- Adicionar m√©todos para verifica√ß√£o de permiss√µes:",
    "priority": "alta",
    "category": "Models",
    "code_example": "pub fn can_access(&self, resource: &str) -> bool {\n       // Verifica√ß√£o mais avan√ßada de permiss√µes\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 200,
    "title": "Sanitiza√ß√£o de email/username",
    "description": "- Adicionar m√©todos para normaliza√ß√£o:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "pub fn normalize_email(email: &str) -> String {\n       // Implementa√ß√£o para normalizar email antes de armazenar\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "user",
      "email"
    ],
    "context": "Models"
  },
  {
    "id": 201,
    "title": "Verifica√ß√£o contra senhas vazadas",
    "description": "- Integrar com APIs de verifica√ß√£o:",
    "priority": "alta",
    "category": "Utils",
    "code_example": "pub async fn check_if_password_is_pwned(password: &str) -> Result<bool, ApiError> {\n       // Implementa√ß√£o usando k-anonimidade e API HIBP\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "password",
      "api"
    ],
    "context": "Utils"
  },
  {
    "id": 202,
    "title": "Sugest√£o de senha segura",
    "description": "- Adicionar gerador de senhas fortes:",
    "priority": "baixa",
    "category": "Utils",
    "code_example": "pub fn generate_secure_password(length: usize) -> String {\n       // Implementa√ß√£o para gerar senha segura aleat√≥ria\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "password"
    ],
    "context": "Utils"
  },
  {
    "id": 203,
    "title": "Configura√ß√£o por perfil",
    "description": "- Adicionar regras diferenciadas por tipo de usu√°rio:",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub fn check_password_strength_for_role(password: &str, role: &str) -> Result<(), Vec<String>> {\n       // Verifica√ß√£o adaptada por tipo de usu√°rio/papel\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "user",
      "config"
    ],
    "context": "Utils"
  },
  {
    "id": 204,
    "title": "Dicion√°rio personalizado",
    "description": "- Implementar verifica√ß√£o contra palavras comuns:",
    "priority": "alta",
    "category": "Utils",
    "code_example": "pub fn load_custom_dictionary(path: &str) -> Result<(), ApiError> {\n       // Carrega lista personalizada de palavras proibidas\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 205,
    "title": "Verifica√ß√£o de contexto",
    "description": "- Evitar senhas baseadas em informa√ß√µes do usu√°rio:",
    "priority": "baixa",
    "category": "Utils",
    "code_example": "pub fn check_context_based_password(\n       password: &str, \n       user_info: &UserContextInfo\n   ) -> Result<(), Vec<String>> {\n       // Verifica se a senha cont√©m informa√ß√µes do usu√°rio\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "password",
      "user"
    ],
    "context": "Utils"
  },
  {
    "id": 206,
    "title": "Suporte a tokens com escopo",
    "description": "- Adicionar campo de permiss√µes espec√≠ficas:",
    "priority": "alta",
    "category": "Models",
    "code_example": "pub struct TokenClaims {\n       // Campos existentes\n       pub scopes: Vec<String>, // Escopos de permiss√£o\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "jwt"
    ],
    "context": "Models"
  },
  {
    "id": 207,
    "title": "Hist√≥rico de logins",
    "description": "- Adicionar estrutura para rastrear sess√µes:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct LoginHistory {\n       pub id: String,\n       pub user_id: String,\n       pub ip_address: String,\n       pub user_agent: String,\n       pub login_time: DateTime<Utc>,\n       pub success: bool,\n       pub failure_reason: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "log",
      "auth"
    ],
    "context": "Models"
  },
  {
    "id": 208,
    "title": "Detec√ß√£o de dispositivos",
    "description": "- Melhorar reconhecimento de dispositivos:",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct DeviceInfo {\n       pub device_id: String,\n       pub device_type: DeviceType,\n       pub os: String,\n       pub browser: String,\n       pub is_mobile: bool,\n       pub is_trusted: bool,\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 209,
    "title": "Rota√ß√£o de tokens",
    "description": "- Suporte para rota√ß√£o segura de refresh tokens:",
    "priority": "alta",
    "category": "Models",
    "code_example": "impl RefreshToken {\n       pub fn rotate(&self) -> Self {\n           let new_expires_at = Utc::now() + Duration::days(self.expiration_days);\n           let mut new_token = self.clone();\n           new_token.id = Uuid::new_v4().to_string();\n           new_token.previous_token_id = Some(self.id.clone());\n           new_token.expires_at = new_expires_at;\n           new_token\n       }\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "jwt"
    ],
    "context": "Models"
  },
  {
    "id": 210,
    "title": "Geolocaliza√ß√£o de sess√µes",
    "description": "- Adicionar informa√ß√µes geogr√°ficas:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct LocationInfo {\n       pub country: Option<String>,\n       pub city: Option<String>,\n       pub latitude: Option<f64>,\n       pub longitude: Option<f64>,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "geolocation"
    ],
    "context": "Models"
  },
  {
    "id": 211,
    "title": "Prote√ß√£o contra ataques de for√ßa bruta",
    "description": "- Implementar backoff exponencial:",
    "priority": "alta",
    "category": "Services",
    "code_example": "fn calculate_lockout_duration(failed_attempts: i32) -> Duration {\n       let base_seconds = 30;\n       let factor = 2_i32.pow(std::cmp::min(failed_attempts, 10) as u32);\n       Duration::seconds(base_seconds * factor as i64)\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "seguran√ßa"
    ],
    "context": "Services"
  },
  {
    "id": 212,
    "title": "Detec√ß√£o de anomalias",
    "description": "- Adicionar verifica√ß√µes de comportamento suspeito:",
    "priority": "baixa",
    "category": "Services",
    "code_example": "pub async fn check_for_suspicious_activity(\n       pool: &DbPool,\n       user_id: &str,\n       ip_address: &str,\n       user_agent: &str\n   ) -> Result<SuspiciousActivityLevel, ApiError> {\n       // Implementa√ß√£o para detec√ß√£o de anomalias\n   }",
    "status": "pendente",
    "tags": [
      "services"
    ],
    "context": "Services"
  },
  {
    "id": 213,
    "title": "Suporte a m√∫ltiplos fatores",
    "description": "- Melhorar integra√ß√£o com 2FA/MFA:",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub async fn verify_multi_factor(\n       pool: &DbPool,\n       user_id: &str,\n       verification_type: MfaType,\n       verification_code: &str\n   ) -> Result<bool, ApiError> {\n       // Implementa√ß√£o verifica√ß√£o multi-fator\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "2fa"
    ],
    "context": "Services"
  },
  {
    "id": 214,
    "title": "Revoga√ß√£o em cascata",
    "description": "- Revogar todas as sess√µes ao mudar senha:",
    "priority": "alta",
    "category": "Services",
    "code_example": "pub async fn revoke_all_sessions_for_user(\n       pool: &DbPool,\n       user_id: &str,\n       reason: &str\n   ) -> Result<usize, ApiError> {\n       // Implementa√ß√£o para revogar todas as sess√µes\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "password"
    ],
    "context": "Services"
  },
  {
    "id": 215,
    "title": "Analytics de autentica√ß√£o",
    "description": "- Coletar m√©tricas para dashboard:",
    "priority": "baixa",
    "category": "Services",
    "code_example": "pub async fn get_auth_statistics(\n       pool: &DbPool,\n       start_date: DateTime<Utc>,\n       end_date: DateTime<Utc>\n   ) -> Result<AuthStatistics, ApiError> {\n       // Implementa√ß√£o para coletar estat√≠sticas\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "jwt",
      "auth"
    ],
    "context": "Services"
  },
  {
    "id": 216,
    "title": "Verifica√ß√£o de reputa√ß√£o",
    "description": "- Implementar verifica√ß√£o de entregabilidade:",
    "priority": "alta",
    "category": "Services",
    "code_example": "pub async fn check_email_reputation(email: &str) -> Result<EmailReputation, ApiError> {\n       // Implementa√ß√£o para verificar reputa√ß√£o do dom√≠nio/email\n   }",
    "status": "pendente",
    "tags": [
      "services"
    ],
    "context": "Services"
  },
  {
    "id": 217,
    "title": "Templates HTML/Text",
    "description": "- Melhorar suporte a vers√µes alternativas:",
    "priority": "baixa",
    "category": "Services",
    "code_example": "pub struct EmailTemplate {\n       pub html_version: String,\n       pub text_version: String,\n       pub subject: String,\n       pub preview_text: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "services"
    ],
    "context": "Services"
  },
  {
    "id": 218,
    "title": "Providers alternativos",
    "description": "- Adicionar suporte para m√∫ltiplos provedores:",
    "priority": "m√©dia",
    "category": "Services",
    "code_example": "pub enum EmailProvider {\n       SMTP(SmtpConfig),\n       SendGrid(SendGridConfig),\n       Mailgun(MailgunConfig),\n       AmazonSES(SESConfig),\n   }",
    "status": "pendente",
    "tags": [
      "services"
    ],
    "context": "Services"
  },
  {
    "id": 219,
    "title": "Assinatura DKIM/SPF",
    "description": "- Implementar assinatura de emails:",
    "priority": "alta",
    "category": "Services",
    "code_example": "pub fn configure_dkim(\n       private_key_path: &str,\n       selector: &str,\n       domain: &str\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o para configurar DKIM\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "email"
    ],
    "context": "Services"
  },
  {
    "id": 220,
    "title": "An√°lise de engajamento",
    "description": "- Rastrear abertura e cliques:",
    "priority": "baixa",
    "category": "Services",
    "code_example": "pub struct EmailTrackingData {\n       pub opened: bool,\n       pub opened_at: Option<DateTime<Utc>>,\n       pub clicked: bool,\n       pub clicked_at: Option<DateTime<Utc>>,\n       pub clicked_link: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "services",
      "risk"
    ],
    "context": "Services"
  },
  {
    "id": 221,
    "title": "Versionamento de API",
    "description": "- Adicionar informa√ß√µes de vers√£o:",
    "priority": "alta",
    "category": "Models",
    "code_example": "pub struct ApiResponseEnvelope<T> {\n       pub data: ApiResponse<T>,\n       pub api_version: String,\n       pub request_id: String,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "api"
    ],
    "context": "Models"
  },
  {
    "id": 222,
    "title": "Metadados de performance",
    "description": "- Adicionar informa√ß√µes de tempo:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "pub struct ApiResponseMetadata {\n       pub processing_time_ms: u64,\n       pub database_queries: u32,\n       pub cached_results: bool,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "cache"
    ],
    "context": "Models"
  },
  {
    "id": 223,
    "title": "Links HATEOAS",
    "description": "- Adicionar navega√ß√£o para APIs RESTful:",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "#[derive(Serialize)]\n   pub struct ApiLink {\n       pub rel: String,\n       pub href: String,\n       pub method: String,\n   }\n   \n   // Na struct ApiResponse\n   pub links: Vec<ApiLink>,",
    "status": "pendente",
    "tags": [
      "models",
      "api"
    ],
    "context": "Models"
  },
  {
    "id": 224,
    "title": "Sanitiza√ß√£o de erros",
    "description": "- Adicionar fun√ß√£o para ambiente de produ√ß√£o:",
    "priority": "alta",
    "category": "Models",
    "code_example": "pub fn sanitize_for_production<T>(self) -> Self {\n       if self.success {\n           return self;\n       }\n       \n       // Em produ√ß√£o, remover detalhes sens√≠veis dos erros\n       if std::env::var(\"ENVIRONMENT\").unwrap_or_default() == \"production\" {\n           return Self {\n               success: false,\n               message: \"Ocorreu um erro ao processar sua solicita√ß√£o\".to_string(),\n               data: None,\n               errors: None,\n           };\n       }\n       \n       self\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 225,
    "title": "Compress√£o de resposta",
    "description": "- Implementar suporte para grandes payloads:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "pub enum CompressionType {\n       None,\n       Gzip,\n       Brotli,\n   }\n   \n   // M√©todo para comprimir respostas grandes\n   pub fn with_compression(self, compression: CompressionType) -> HttpResponse {\n       // Implementa√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 226,
    "title": "Controle de acesso mais fino",
    "description": "- Implementar verifica√ß√£o baseada em permiss√µes:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "fn check_permission(\n       claims: &TokenClaims, \n       permission: &str,\n       resource_id: Option<&str>\n   ) -> Result<(), ApiError> {\n       // Verifica√ß√£o de permiss√µes mais detalhada\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 227,
    "title": "Suporte para bulk operations",
    "description": "- Adicionar endpoints para opera√ß√µes em lote:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "pub async fn bulk_update_users(\n       pool: web::Data<DbPool>,\n       update_dto: web::Json<BulkUpdateUsersDto>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o para atualiza√ß√£o em lote\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "api"
    ],
    "context": "Controllers"
  },
  {
    "id": 228,
    "title": "Versionamento de endpoints",
    "description": "- Adicionar suporte para m√∫ltiplas vers√µes:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub mod v1 {\n       pub async fn get_user(...) -> Result<impl Responder, ApiError> {\n           // Implementa√ß√£o v1\n       }\n   }\n   \n   pub mod v2 {\n       pub async fn get_user(...) -> Result<impl Responder, ApiError> {\n           // Implementa√ß√£o v2 com campos adicionais\n       }\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "api"
    ],
    "context": "Controllers"
  },
  {
    "id": 229,
    "title": "Auditoria avan√ßada",
    "description": "- Registrar todas as altera√ß√µes:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "fn log_user_change(\n       pool: &DbPool, \n       user_id: &str,\n       admin_id: Option<&str>,\n       change_type: &str,\n       old_value: Option<&str>,\n       new_value: Option<&str>,\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o de log de auditoria\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "log"
    ],
    "context": "Controllers"
  },
  {
    "id": 230,
    "title": "Respostas condicionais",
    "description": "- Suporte para ETag e cache:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "pub async fn get_user_with_caching(\n       pool: web::Data<DbPool>,\n       path: web::Path<String>,\n       claims: web::ReqData<TokenClaims>,\n       req: HttpRequest,\n   ) -> Result<impl Responder, ApiError> {\n       // Implementa√ß√£o com suporte a ETag e If-None-Match\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "cache"
    ],
    "context": "Controllers"
  },
  {
    "id": 231,
    "title": "Suporte para m√∫ltiplos tipos de 2FA",
    "description": "- Adicionar mais m√©todos:",
    "priority": "alta",
    "category": "Models",
    "code_example": "pub enum TwoFactorType {\n       Totp,\n       Sms,\n       Email,\n       Push,\n       WebAuthn,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "2fa"
    ],
    "context": "Models"
  },
  {
    "id": 232,
    "title": "Hist√≥rico de uso",
    "description": "- Rastrear uso de c√≥digos de backup:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct BackupCodeUsage {\n       pub code_hash: String, // Hash do c√≥digo usado\n       pub used_at: DateTime<Utc>,\n       pub ip_address: Option<String>,\n       pub user_agent: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "backup"
    ],
    "context": "Models"
  },
  {
    "id": 233,
    "title": "Configura√ß√£o adaptativa",
    "description": "- Ajustar par√¢metros por n√≠vel de risco:",
    "priority": "m√©dia",
    "category": "Models",
    "code_example": "pub struct TotpConfig {\n       pub digits: u32,\n       pub step: u64,\n       pub window: u64,\n   }\n   \n   pub fn get_totp_config(risk_level: RiskLevel) -> TotpConfig {\n       match risk_level {\n           RiskLevel::Low => TotpConfig { digits: 6, step: 30, window: 1 },\n           RiskLevel::Medium => TotpConfig { digits: 6, step: 30, window: 0 },\n           RiskLevel::High => TotpConfig { digits: 8, step: 15, window: 0 },\n       }\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "config",
      "risk"
    ],
    "context": "Models"
  },
  {
    "id": 234,
    "title": "Notifica√ß√µes de seguran√ßa",
    "description": "- Adicionar eventos para notifica√ß√£o:",
    "priority": "alta",
    "category": "Models",
    "code_example": "pub enum TwoFactorEvent {\n       Enabled,\n       Disabled,\n       BackupCodeUsed,\n       FailedAttempt,\n       ConfigurationChanged,\n   }\n   \n   pub struct TwoFactorNotification {\n       pub event: TwoFactorEvent,\n       pub user_id: String,\n       pub timestamp: DateTime<Utc>,\n       pub details: Option<String>,\n   }",
    "status": "pendente",
    "tags": [
      "models",
      "seguran√ßa",
      "email",
      "webhook"
    ],
    "context": "Models"
  },
  {
    "id": 235,
    "title": "QR code personalizado",
    "description": "- Adicionar marca d'√°gua e customiza√ß√£o:",
    "priority": "baixa",
    "category": "Models",
    "code_example": "#[derive(Debug, Deserialize)]\n   pub struct QrCodeCustomization {\n       pub size: u32,\n       pub dark_color: String,\n       pub light_color: String,\n       pub logo_url: Option<String>,\n       pub border_size: u32,\n   }\n   \n   pub async fn generate_custom_qr(\n       pool: web::Data<DbPool>,\n       options: web::Json<QrCodeCustomization>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para gerar QR code personalizado\n   }",
    "status": "pendente",
    "tags": [
      "models"
    ],
    "context": "Models"
  },
  {
    "id": 236,
    "title": "Mascaramento de dados sens√≠veis",
    "description": "- Implementar filtro para PII e credenciais:",
    "priority": "alta",
    "category": "Utils",
    "code_example": "fn mask_sensitive_fields(record: &tracing::span::Record) -> tracing::span::Record {\n       // Implementa√ß√£o para mascarar campos como senhas, tokens, etc.\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 237,
    "title": "Rastreamento de opera√ß√µes",
    "description": "- Adicionar suporte para OpenTelemetry:",
    "priority": "baixa",
    "category": "Utils",
    "code_example": "pub fn init_opentelemetry(service_name: &str) -> Result<(), ApiError> {\n       // Configura√ß√£o de exporta√ß√£o para sistemas como Jaeger/Zipkin\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 238,
    "title": "Logs para diferentes ambientes",
    "description": "- Configura√ß√£o adaptativa:",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub enum Environment {\n       Development,\n       Staging,\n       Production,\n   }\n   \n   pub fn configure_tracing_for_env(env: Environment) {\n       match env {\n           Environment::Development => { /* config com mais detalhes */ },\n           Environment::Staging => { /* config balanceada */ },\n           Environment::Production => { /* config otimizada e segura */ },\n       }\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "log",
      "config"
    ],
    "context": "Utils"
  },
  {
    "id": 239,
    "title": "Armazenamento seguro",
    "description": "- Rota√ß√£o e backup de logs:",
    "priority": "alta",
    "category": "Utils",
    "code_example": "pub struct LogRetentionPolicy {\n       pub max_file_size_mb: u64,\n       pub max_files: u32,\n       pub rotation_period: Duration,\n       pub compression: bool,\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "log",
      "database",
      "backup"
    ],
    "context": "Utils"
  },
  {
    "id": 240,
    "title": "Alerta baseado em logs",
    "description": "- Detec√ß√£o de padr√µes cr√≠ticos:",
    "priority": "baixa",
    "category": "Utils",
    "code_example": "pub fn configure_log_alerting(patterns: Vec<AlertPattern>) -> Result<(), ApiError> {\n       // Configura√ß√£o para enviar alertas quando certos padr√µes aparecem nos logs\n   }\n   \n   pub struct AlertPattern {\n       pub regex: String,\n       pub level: tracing::Level,\n       pub channel: AlertChannel,\n       pub cooldown: Duration,\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "log"
    ],
    "context": "Utils"
  },
  {
    "id": 241,
    "title": "Implementa√ß√£o de CAPTCHA",
    "description": "- Adicionar prote√ß√£o contra bots:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize, Validate)]\n   pub struct LoginWithCaptchaDto {\n       #[validate(length(min = 3, max = 100))]\n       pub username_or_email: String,\n       #[validate(length(min = 8))]\n       pub password: String,\n       #[validate(required)]\n       pub captcha_token: String,\n   }\n   \n   async fn verify_captcha(token: &str) -> Result<bool, ApiError> {\n       // Implementa√ß√£o para verificar token de CAPTCHA com servi√ßo externo\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa"
    ],
    "context": "Controllers"
  },
  {
    "id": 242,
    "title": "Fingerprinting de dispositivo",
    "description": "- Identificar dispositivos para seguran√ßa adicional:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "pub struct DeviceFingerprint {\n       pub ip_address: String,\n       pub user_agent: String,\n       pub screen_resolution: Option<String>,\n       pub timezone: Option<String>,\n       pub languages: Vec<String>,\n       pub platform: String,\n   }\n   \n   pub async fn login_with_fingerprint(\n       pool: web::Data<DbPool>,\n       login_dto: web::Json<LoginDto>,\n       fingerprint: web::Json<DeviceFingerprint>,\n       config: web::Data<Config>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o com verifica√ß√£o de dispositivos conhecidos\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa"
    ],
    "context": "Controllers"
  },
  {
    "id": 243,
    "title": "M√©tricas detalhadas",
    "description": "- Registrar eventos de autentica√ß√£o para an√°lise:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub struct AuthMetrics {\n       pub attempt_timestamp: DateTime<Utc>,\n       pub success: bool,\n       pub ip_address: String,\n       pub geolocation: Option<GeoLocation>,\n       pub device_type: String,\n       pub failed_reason: Option<String>,\n       pub processing_time_ms: u64,\n   }\n   \n   fn record_auth_metrics(metrics: AuthMetrics) {\n       // Implementa√ß√£o para registrar m√©tricas\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "jwt",
      "auth",
      "webhook",
      "risk"
    ],
    "context": "Controllers"
  },
  {
    "id": 244,
    "title": "Limites adaptativos de tentativas",
    "description": "- Ajustar limites baseados em fatores de risco:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "pub enum RiskFactor {\n       NewLocation,\n       UnknownDevice,\n       MultipleFailures,\n       SuspiciousActivity,\n       NormalActivity,\n   }\n   \n   fn calculate_attempt_limit(factors: &[RiskFactor]) -> u32 {\n       let base_limit = 5;\n       \n       factors.iter().fold(base_limit, |limit, factor| {\n           match factor {\n               RiskFactor::NormalActivity => limit,\n               RiskFactor::NewLocation => limit - 1,\n               RiskFactor::UnknownDevice => limit - 1,\n               RiskFactor::MultipleFailures => limit - 2,\n               RiskFactor::SuspiciousActivity => 2, // Limite estrito para atividades suspeitas\n           }\n       })\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "risk",
      "rate-limit"
    ],
    "context": "Controllers"
  },
  {
    "id": 245,
    "title": "Login progressivo",
    "description": "- Implementar autentica√ß√£o em etapas:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub enum AuthStage {\n       Initial,\n       TwoFactor,\n       RecoveryCode,\n       SecurityQuestions,\n       Complete,\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub struct ProgressiveAuthResponse {\n       pub stage: AuthStage,\n       pub session_id: String,\n       pub next_action: String,\n       pub expires_in: i64,\n   }\n   \n   pub async fn start_progressive_auth(\n       pool: web::Data<DbPool>,\n       credentials: web::Json<LoginDto>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o de fluxo de login progressivo\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "jwt",
      "log",
      "auth"
    ],
    "context": "Controllers"
  },
  {
    "id": 246,
    "title": "Verifica√ß√£o de dispositivo confi√°vel",
    "description": "- Permitir dispositivos sem 2FA:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize)]\n   pub struct TrustedDeviceRequest {\n       pub device_name: String,\n       pub remember_device: bool,\n       pub device_id: String,\n   }\n   \n   pub async fn mark_device_as_trusted(\n       pool: web::Data<DbPool>,\n       req: web::Json<TrustedDeviceRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para marcar dispositivo como confi√°vel\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "2fa"
    ],
    "context": "Controllers"
  },
  {
    "id": 247,
    "title": "Rastreamento de sess√µes 2FA",
    "description": "- Manter hist√≥rico para seguran√ßa:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct TwoFactorSessionLog {\n       pub id: String,\n       pub user_id: String,\n       pub verification_time: DateTime<Utc>,\n       pub success: bool,\n       pub method: String,\n       pub ip_address: String,\n       pub device_info: String,\n   }\n   \n   fn log_2fa_attempt(\n       pool: &DbPool,\n       user_id: &str,\n       success: bool,\n       method: &str,\n       ip: &str,\n       device: &str,\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o para registrar tentativa de 2FA\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa",
      "2fa"
    ],
    "context": "Controllers"
  },
  {
    "id": 248,
    "title": "M√©todos alternativos de 2FA",
    "description": "- Suporte a SMS e email:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub enum TwoFactorMethod {\n       Totp,\n       Sms,\n       Email,\n       PushNotification,\n   }\n   \n   pub async fn setup_alternative_2fa(\n       pool: web::Data<DbPool>,\n       method: web::Path<String>,\n       contact: web::Json<AlternativeContactDto>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para configurar 2FA alternativo\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "email",
      "2fa"
    ],
    "context": "Controllers"
  },
  {
    "id": 249,
    "title": "Pol√≠ticas de 2FA por grupo",
    "description": "- Aplicar regras por grupos de usu√°rios:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "pub struct TwoFactorPolicy {\n       pub group_id: String,\n       pub require_2fa: bool,\n       pub allowed_methods: Vec<TwoFactorMethod>,\n       pub grace_period_days: u32,\n       pub bypass_ips: Vec<String>,\n   }\n   \n   async fn check_2fa_policy(\n       pool: &DbPool,\n       user_id: &str,\n       ip_address: &str,\n   ) -> Result<TwoFactorRequirement, ApiError> {\n       // Implementa√ß√£o para verificar pol√≠tica de 2FA aplic√°vel\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "user",
      "2fa"
    ],
    "context": "Controllers"
  },
  {
    "id": 250,
    "title": "QR code personalizado",
    "description": "- Adicionar marca d'√°gua e customiza√ß√£o:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize)]\n   pub struct QrCodeCustomization {\n       pub size: u32,\n       pub dark_color: String,\n       pub light_color: String,\n       pub logo_url: Option<String>,\n       pub border_size: u32,\n   }\n   \n   pub async fn generate_custom_qr(\n       pool: web::Data<DbPool>,\n       options: web::Json<QrCodeCustomization>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para gerar QR code personalizado\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 251,
    "title": "Verifica√ß√£o progressiva",
    "description": "- Permitir acesso limitado sem verifica√ß√£o:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "pub enum VerificationLevel {\n       None,\n       Pending,\n       Verified,\n   }\n   \n   pub struct EmailAccess {\n       pub level: VerificationLevel,\n       pub can_read: bool,\n       pub can_send: bool,\n       pub can_change_settings: bool,\n   }\n   \n   fn get_access_level(verification_status: &VerificationLevel) -> EmailAccess {\n       match verification_status {\n           VerificationLevel::None => EmailAccess {\n               level: VerificationLevel::None,\n               can_read: false,\n               can_send: false,\n               can_change_settings: false,\n           },\n           VerificationLevel::Pending => EmailAccess {\n               level: VerificationLevel::Pending,\n               can_read: true,\n               can_send: false,\n               can_change_settings: false,\n           },\n           VerificationLevel::Verified => EmailAccess {\n               level: VerificationLevel::Verified,\n               can_read: true,\n               can_send: true,\n               can_change_settings: true,\n           },\n       }\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 252,
    "title": "Link m√°gico de verifica√ß√£o",
    "description": "- Implementar login via email:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "pub async fn request_magic_link(\n       pool: web::Data<DbPool>,\n       email_dto: web::Json<EmailDto>,\n       config: web::Data<Config>,\n       email_service: web::Data<EmailService>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para gerar e enviar link m√°gico\n   }\n   \n   pub async fn verify_magic_link(\n       pool: web::Data<DbPool>,\n       token: web::Path<String>,\n       config: web::Data<Config>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para verificar link m√°gico e autenticar\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "log",
      "auth",
      "email"
    ],
    "context": "Controllers"
  },
  {
    "id": 253,
    "title": "Preven√ß√£o de abuso",
    "description": "- Limitar tentativas de verifica√ß√£o:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "struct VerificationRateLimit {\n       pub email: String,\n       pub attempt_count: u32,\n       pub first_attempt: DateTime<Utc>,\n       pub last_attempt: DateTime<Utc>,\n       pub is_blocked: bool,\n       pub block_expires: Option<DateTime<Utc>>,\n   }\n   \n   async fn check_verification_rate_limit(\n       pool: &DbPool,\n       email: &str,\n   ) -> Result<bool, ApiError> {\n       // Implementa√ß√£o para verificar limites de tentativas\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 254,
    "title": "Templates personalizados",
    "description": "- Suporte a temas e marcas:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct EmailTemplate {\n       pub name: String,\n       pub subject: String,\n       pub html_body: String,\n       pub text_body: String,\n       pub preview_text: String,\n       pub brand_id: Option<String>,\n       pub color_scheme: HashMap<String, String>,\n   }\n   \n   pub async fn set_verification_template(\n       pool: web::Data<DbPool>,\n       template: web::Json<EmailTemplate>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para configurar template personalizado\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 255,
    "title": "Consent din√¢mico",
    "description": "- Permitir usu√°rio escolher escopos:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct ConsentRequest {\n       pub client: OAuthClientInfo,\n       pub scopes: Vec<ScopeInfo>,\n       pub user: UserBasicInfo,\n       pub consent_id: String,\n       pub expires_in: i64,\n   }\n   \n   #[derive(Debug, Deserialize)]\n   pub struct ConsentResponse {\n       pub consent_id: String,\n       pub approved_scopes: Vec<String>,\n       pub remember_consent: bool,\n   }\n   \n   pub async fn request_user_consent(\n       pool: web::Data<DbPool>,\n       auth_request: web::Query<AuthorizationRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para solicitar consentimento\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "user"
    ],
    "context": "Controllers"
  },
  {
    "id": 256,
    "title": "Token com limita√ß√£o de uso",
    "description": "- Definir limite de utiliza√ß√µes:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct LimitedUseToken {\n       pub token: String,\n       pub max_uses: u32,\n       pub current_uses: u32,\n       pub expires_at: DateTime<Utc>,\n       pub is_active: bool,\n   }\n   \n   pub async fn issue_limited_token(\n       pool: web::Data<DbPool>,\n       request: web::Json<LimitedTokenRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para emitir token de uso limitado\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "jwt",
      "rate-limit"
    ],
    "context": "Controllers"
  },
  {
    "id": 257,
    "title": "Revoga√ß√£o em cascata",
    "description": "- Revogar tokens relacionados:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "pub async fn revoke_all_tokens(\n       pool: web::Data<DbPool>,\n       client_id: web::Path<String>,\n       user_id: Option<web::Query<String>>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para revogar todos os tokens relacionados\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "jwt"
    ],
    "context": "Controllers"
  },
  {
    "id": 258,
    "title": "Verifica√ß√µes de depend√™ncias",
    "description": "- Testar componentes do sistema:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct HealthCheckResult {\n       pub status: HealthStatus,\n       pub version: String,\n       pub uptime: u64,\n       pub components: HashMap<String, ComponentHealth>,\n       pub timestamp: DateTime<Utc>,\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub struct ComponentHealth {\n       pub status: HealthStatus,\n       pub latency_ms: u64,\n       pub message: Option<String>,\n       pub last_checked: DateTime<Utc>,\n   }\n   \n   pub async fn check_system_health(\n       pool: web::Data<DbPool>,\n       cache: web::Data<Cache>,\n       email_service: web::Data<EmailService>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para verificar sa√∫de de todos os componentes\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 259,
    "title": "M√©tricas detalhadas",
    "description": "- Expor dados de performance:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct SystemMetrics {\n       pub cpu_usage: f64,\n       pub memory_usage: f64,\n       pub active_connections: u32,\n       pub request_rate: f64,\n       pub average_response_time: f64,\n       pub error_rate: f64,\n       pub db_pool_stats: DbPoolStats,\n   }\n   \n   pub async fn get_metrics(\n       pool: web::Data<DbPool>,\n       _req: HttpRequest,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para coletar e retornar m√©tricas\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "cache"
    ],
    "context": "Controllers"
  },
  {
    "id": 260,
    "title": "Manuten√ß√£o programada",
    "description": "- Informar sobre janelas de manuten√ß√£o:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct MaintenanceWindow {\n       pub id: String,\n       pub start_time: DateTime<Utc>,\n       pub end_time: DateTime<Utc>,\n       pub description: String,\n       pub affected_services: Vec<String>,\n       pub status: MaintenanceStatus,\n   }\n   \n   pub async fn get_maintenance_schedule(\n       _req: HttpRequest,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para retornar informa√ß√µes de manuten√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 261,
    "title": "Verifica√ß√£o de seguran√ßa",
    "description": "- Avaliar status de seguran√ßa:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct SecurityStatus {\n       pub last_security_scan: DateTime<Utc>,\n       pub open_vulnerabilities: u32,\n       pub certificate_expiry: DateTime<Utc>,\n       pub firewall_status: String,\n       pub updates_available: bool,\n   }\n   \n   pub async fn security_health_check(\n       _req: HttpRequest,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para verificar status de seguran√ßa (admin only)\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "seguran√ßa"
    ],
    "context": "Controllers"
  },
  {
    "id": 262,
    "title": "Status personalizado",
    "description": "- P√°gina de status p√∫blica:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "pub async fn status_page(\n       pool: web::Data<DbPool>,\n       template: web::Data<Handlebars>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para gerar p√°gina HTML de status\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub struct StatusPageData {\n       pub system_status: HealthStatus,\n       pub last_updated: String,\n       pub services: Vec<ServiceStatus>,\n       pub incidents: Vec<Incident>,\n       pub uptime_percentage: f64,\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 263,
    "title": "Detec√ß√£o de anomalias",
    "description": "- Identificar uso suspeito:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct DeviceAnomalyReport {\n       pub user_id: String,\n       pub device_id: String,\n       pub anomaly_type: AnomalyType,\n       pub confidence: f64,\n       pub detected_at: DateTime<Utc>,\n       pub context: HashMap<String, String>,\n   }\n   \n   #[derive(Debug, Serialize, Deserialize)]\n   pub enum AnomalyType {\n       UnusualLocation,\n       UnexpectedLoginTime,\n       RapidGeoMovement,\n       MultipleFailedAttempts,\n       UnusualBehavior,\n   }\n   \n   pub async fn detect_device_anomalies(\n       pool: web::Data<DbPool>,\n       user_id: web::Path<String>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para detectar anomalias nos dispositivos do usu√°rio\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 264,
    "title": "Nome e √≠cone para dispositivos",
    "description": "- Melhorar reconhecimento:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize, Validate)]\n   pub struct DeviceCustomizationRequest {\n       #[validate(length(min = 1, max = 50))]\n       pub display_name: String,\n       pub icon_type: DeviceIconType,\n       pub color: Option<String>,\n   }\n   \n   #[derive(Debug, Serialize, Deserialize)]\n   pub enum DeviceIconType {\n       Desktop,\n       Laptop,\n       Phone,\n       Tablet,\n       Watch,\n       TV,\n       Other,\n   }\n   \n   pub async fn customize_device(\n       pool: web::Data<DbPool>,\n       device_id: web::Path<String>,\n       request: web::Json<DeviceCustomizationRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para personalizar dispositivo\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 265,
    "title": "Notifica√ß√µes de login",
    "description": "- Alertar sobre novos dispositivos:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct LoginNotification {\n       pub device_info: DeviceInfo,\n       pub location: Option<LocationInfo>,\n       pub login_time: DateTime<Utc>,\n       pub ip_address: String,\n   }\n   \n   pub async fn send_new_device_notification(\n       pool: &DbPool,\n       user_id: &str,\n       device_id: &str,\n       email_service: &EmailService,\n   ) -> Result<(), ApiError> {\n       // Implementa√ß√£o para enviar notifica√ß√£o quando um novo dispositivo faz login\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "log",
      "auth"
    ],
    "context": "Controllers"
  },
  {
    "id": 266,
    "title": "Aprova√ß√£o de dispositivos",
    "description": "- Verifica√ß√£o em dois passos para novos dispositivos:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct DeviceApprovalRequest {\n       pub device_id: String,\n       pub approval_token: String,\n       pub user_id: String,\n       pub expires_at: DateTime<Utc>,\n   }\n   \n   pub async fn request_device_approval(\n       pool: web::Data<DbPool>,\n       device_id: web::Path<String>,\n       claims: web::ReqData<TokenClaims>,\n       email_service: web::Data<EmailService>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para solicitar aprova√ß√£o de dispositivo\n   }\n   \n   pub async fn approve_device(\n       pool: web::Data<DbPool>,\n       token: web::Path<String>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para aprovar dispositivo via link de email\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 267,
    "title": "Sincroniza√ß√£o entre dispositivos",
    "description": "- Notifica√ß√µes instant√¢neas:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct DeviceNotification {\n       pub id: String,\n       pub user_id: String,\n       pub title: String,\n       pub body: String,\n       pub action: Option<NotificationAction>,\n       pub created_at: DateTime<Utc>,\n       pub expires_at: Option<DateTime<Utc>>,\n       pub priority: NotificationPriority,\n   }\n   \n   pub async fn send_notification_to_devices(\n       pool: web::Data<DbPool>,\n       notification: web::Json<DeviceNotification>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para enviar notifica√ß√£o para todos os dispositivos\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 268,
    "title": "An√°lise de for√ßa das respostas",
    "description": "- Evitar respostas √≥bvias:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "fn evaluate_answer_strength(question_id: &str, answer: &str) -> AnswerStrength {\n       // Implementa√ß√£o para avaliar quanto uma resposta √© previs√≠vel para a pergunta\n       \n       let answer_length = answer.len();\n       let contains_numbers = answer.chars().any(|c| c.is_numeric());\n       let common_answer = check_common_answer(question_id, answer);\n       \n       if common_answer {\n           return AnswerStrength::Weak;\n       }\n       \n       if answer_length < 5 || !contains_numbers {\n           return AnswerStrength::Medium;\n       }\n       \n       AnswerStrength::Strong\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub enum AnswerStrength {\n       Weak,\n       Medium,\n       Strong,\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "risk"
    ],
    "context": "Controllers"
  },
  {
    "id": 269,
    "title": "Perguntas personalizadas",
    "description": "- Permitir perguntas definidas pelo usu√°rio:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Deserialize, Validate)]\n   pub struct CustomSecurityQuestionRequest {\n       #[validate(length(min = 10, max = 200))]\n       pub question_text: String,\n       #[validate(length(min = 3, max = 100))]\n       pub answer: String,\n       pub hint: Option<String>,\n   }\n   \n   pub async fn add_custom_security_question(\n       pool: web::Data<DbPool>,\n       request: web::Json<CustomSecurityQuestionRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para adicionar pergunta personalizada\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "user"
    ],
    "context": "Controllers"
  },
  {
    "id": 270,
    "title": "Rota√ß√£o de perguntas",
    "description": "- Exigir atualiza√ß√£o peri√≥dica:",
    "priority": "m√©dia",
    "category": "Controllers",
    "code_example": "pub struct SecurityQuestionPolicy {\n       pub min_questions_required: u32,\n       pub rotation_interval_days: u32,\n       pub prevent_reuse: bool,\n       pub min_answer_length: u32,\n   }\n   \n   pub async fn check_questions_expiry(\n       pool: web::Data<DbPool>,\n       user_id: web::Path<String>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para verificar se √© necess√°rio atualizar perguntas\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 271,
    "title": "Verifica√ß√£o progressiva",
    "description": "- Aumentar quantidade de perguntas com base no risco:",
    "priority": "alta",
    "category": "Controllers",
    "code_example": "pub async fn get_verification_questions(\n       pool: web::Data<DbPool>,\n       user_email: web::Json<EmailDto>,\n       risk_score: Option<web::Query<u32>>,\n   ) -> Result<HttpResponse, ApiError> {\n       let risk = risk_score.map(|r| r.into_inner()).unwrap_or(0);\n       \n       // N√∫mero de perguntas baseado no n√≠vel de risco\n       let questions_count = match risk {\n           0..=20 => 1, // Baixo risco\n           21..=60 => 2, // M√©dio risco\n           _ => 3,       // Alto risco\n       };\n       \n       // Implementa√ß√£o para selecionar perguntas para verifica√ß√£o\n   }",
    "status": "pendente",
    "tags": [
      "controllers",
      "risk"
    ],
    "context": "Controllers"
  },
  {
    "id": 272,
    "title": "Dicas visuais",
    "description": "- Adicionar imagens para mem√≥ria:",
    "priority": "baixa",
    "category": "Controllers",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct VisualSecurityQuestion {\n       pub id: String,\n       pub user_id: String,\n       pub image_type: VisualQuestionType,\n       pub correct_answer: String, // Hash da resposta\n       pub created_at: DateTime<Utc>,\n   }\n   \n   #[derive(Debug, Serialize, Deserialize)]\n   pub enum VisualQuestionType {\n       PatternSelect,\n       ImageSequence,\n       ColorChoices,\n       ImageRecognition,\n   }\n   \n   pub async fn setup_visual_security_question(\n       pool: web::Data<DbPool>,\n       request: web::Json<SetupVisualQuestionRequest>,\n       claims: web::ReqData<TokenClaims>,\n   ) -> Result<HttpResponse, ApiError> {\n       // Implementa√ß√£o para configurar pergunta visual\n   }",
    "status": "pendente",
    "tags": [
      "controllers"
    ],
    "context": "Controllers"
  },
  {
    "id": 273,
    "title": "Rota√ß√£o autom√°tica de chaves",
    "description": "- Implementar gerenciamento de chaves:",
    "priority": "alta",
    "category": "Utils",
    "code_example": "pub struct JwtKeyManager {\n       pub current_key: String,\n       pub previous_keys: Vec<String>,\n       pub current_kid: String,\n       pub key_rotation_date: DateTime<Utc>,\n       pub rotation_interval_days: u32,\n   }\n   \n   impl JwtKeyManager {\n       pub fn new(initial_key: String, rotation_interval_days: u32) -> Self {\n           let current_kid = Uuid::new_v4().to_string();\n           Self {\n               current_key: initial_key,\n               previous_keys: Vec::new(),\n               current_kid,\n               key_rotation_date: Utc::now(),\n               rotation_interval_days,\n           }\n       }\n       \n       pub fn rotate_if_needed(&mut self) -> bool {\n           let now = Utc::now();\n           let rotation_duration = Duration::days(self.rotation_interval_days as i64);\n           \n           if now > self.key_rotation_date + rotation_duration {\n               self.rotate_key();\n               return true;\n           }\n           \n           false\n       }\n       \n       fn rotate_key(&mut self) {\n           let new_key = generate_secure_key();\n           let new_kid = Uuid::new_v4().to_string();\n           \n           // Guardar chave anterior\n           self.previous_keys.push(self.current_key.clone());\n           \n           // Limitar n√∫mero de chaves antigas armazenadas\n           if self.previous_keys.len() > 5 {\n               self.previous_keys.remove(0);\n           }\n           \n           // Atualizar chave atual\n           self.current_key = new_key;\n           self.current_kid = new_kid;\n           self.key_rotation_date = Utc::now();\n       }\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 274,
    "title": "Suporte a JWK",
    "description": "- Disponibilizar chaves para verifica√ß√£o:",
    "priority": "baixa",
    "category": "Utils",
    "code_example": "#[derive(Debug, Serialize)]\n   pub struct Jwk {\n       pub kid: String,\n       pub kty: String,\n       pub alg: String,\n       pub use_field: String,\n       pub n: String,\n       pub e: String,\n   }\n   \n   #[derive(Debug, Serialize)]\n   pub struct JwkSet {\n       pub keys: Vec<Jwk>,\n   }\n   \n   pub fn get_public_jwks() -> JwkSet {\n       // Implementa√ß√£o para gerar JWK Set a partir das chaves p√∫blicas\n   }",
    "status": "pendente",
    "tags": [
      "utils"
    ],
    "context": "Utils"
  },
  {
    "id": 275,
    "title": "Verifica√ß√£o de blacklist",
    "description": "- Checar tokens revogados:",
    "priority": "m√©dia",
    "category": "Utils",
    "code_example": "pub struct TokenBlacklist {\n       blacklisted: Arc<RwLock<HashMap<String, DateTime<Utc>>>>,\n   }\n   \n   impl TokenBlacklist {\n       pub fn new() -> Self {\n           Self {\n               blacklisted: Arc::new(RwLock::new(HashMap::new())),\n           }\n       }\n       \n       pub fn add(&self, token_id: String, expiry: DateTime<Utc>) {\n           let mut map = self.blacklisted.write().unwrap();\n           map.insert(token_id, expiry);\n       }\n       \n       pub fn is_blacklisted(&self, token_id: &str) -> bool {\n           let map = self.blacklisted.read().unwrap();\n           map.contains_key(token_id)\n       }\n       \n       pub fn clean_expired(&self) -> usize {\n           let now = Utc::now();\n           let mut map = self.blacklisted.write().unwrap();\n           let initial_size = map.len();\n           \n           map.retain(|_, expiry| *expiry > now);\n           \n           initial_size - map.len()\n       }\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "jwt"
    ],
    "context": "Utils"
  },
  {
    "id": 276,
    "title": "Token com uso √∫nico",
    "description": "- Implementar nonce para JWT:",
    "priority": "baixa",
    "category": "Utils",
    "code_example": "#[derive(Debug, Serialize, Deserialize)]\n   pub struct NonceTokenClaims {\n       pub sub: String,\n       pub exp: i64,\n       pub iat: i64,\n       pub nonce: String,\n   }\n   \n   pub fn generate_nonce_token(\n       user_id: &str, \n       expiration_minutes: i64, \n       secret: &str,\n       nonce_store: &NonceStore,\n   ) -> Result<String, ApiError> {\n       let now = Utc::now();\n       let expiry = now + Duration::minutes(expiration_minutes);\n       let nonce = Uuid::new_v4().to_string();\n       \n       // Salvar nonce no store\n       nonce_store.add_nonce(&nonce, expiry);\n       \n       let claims = NonceTokenClaims {\n           sub: user_id.to_string(),\n           exp: expiry.timestamp(),\n           iat: now.timestamp(),\n           nonce,\n       };\n       \n       // Resto da implementa√ß√£o para gerar o token\n   }",
    "status": "pendente",
    "tags": [
      "utils",
      "jwt"
    ],
    "context": "Utils"
  },
  {
    "id": 277,
    "title": "Verifica√ß√£o peri√≥dica de integridade",
    "description": "- Garantir consist√™ncia:",
    "priority": "alta",
    "category": "Db",
    "code_example": "pub struct DbHealthMonitor {\n       check_interval: Duration,\n       last_check: Mutex<DateTime<Utc>>,\n       health_status: RwLock<DbHealthStatus>,\n   }\n   \n   #[derive(Debug, Clone, Serialize)]\n   pub struct DbHealthStatus {\n       pub status: HealthLevel,\n       pub last_checked_at: DateTime<Utc>,\n       pub response_time_ms: u64,\n       pub connection_count: u32,\n       pub error_message: Option<String>,\n   }\n   \n   impl DbHealthMonitor {\n       pub fn new(check_interval_secs: u64) -> Self {\n           Self {\n               check_interval: Duration::seconds(check_interval_secs as i64),\n               last_check: Mutex::new(Utc::now()),\n               health_status: RwLock::new(DbHealthStatus {\n                   status: HealthLevel::Unknown,\n                   last_checked_at: Utc::now(),\n                   response_time_ms: 0,\n                   connection_count: 0,\n                   error_message: None,\n               }),\n           }\n       }\n       \n       pub async fn start_monitoring(self: Arc<Self>, pool: DbPool) {\n           tokio::spawn(async move {\n               loop {\n                   self.perform_health_check(&pool).await;\n                   tokio::time::sleep(self.check_interval.to_std().unwrap()).await;\n               }\n           });\n       }\n       \n       async fn perform_health_check(&self, pool: &DbPool) {\n           // Implementa√ß√£o para verificar sa√∫de do banco de dados\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 278,
    "title": "M√©tricas de pool de conex√£o",
    "description": "- Monitorar utiliza√ß√£o:",
    "priority": "baixa",
    "category": "Db",
    "code_example": "#[derive(Debug, Clone, Serialize)]\n   pub struct DbPoolMetrics {\n       pub available_connections: u32,\n       pub used_connections: u32,\n       pub max_connections: u32,\n       pub usage_percentage: f64,\n       pub wait_count: u64,\n       pub max_wait_time_ms: u64,\n       pub avg_wait_time_ms: f64,\n       pub recorded_at: DateTime<Utc>,\n   }\n   \n   pub fn collect_pool_metrics(pool: &DbPool) -> DbPoolMetrics {\n       let state = pool.state();\n       \n       DbPoolMetrics {\n           available_connections: state.idle_connections as u32,\n           used_connections: state.connections - state.idle_connections as u32,\n           max_connections: pool.max_size() as u32,\n           usage_percentage: (state.connections as f64 - state.idle_connections as f64) \n               / pool.max_size() as f64 * 100.0,\n           wait_count: 0, // Obter de estat√≠sticas reais\n           max_wait_time_ms: 0, // Obter de estat√≠sticas reais\n           avg_wait_time_ms: 0.0, // Obter de estat√≠sticas reais\n           recorded_at: Utc::now(),\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db",
      "monitoring"
    ],
    "context": "Db"
  },
  {
    "id": 279,
    "title": "Janela de manuten√ß√£o automatizada",
    "description": "- Executar opera√ß√µes de manuten√ß√£o:",
    "priority": "m√©dia",
    "category": "Db",
    "code_example": "pub struct DbMaintenance {\n       maintenance_tasks: Vec<MaintenanceTask>,\n       schedule: MaintenanceSchedule,\n   }\n   \n   #[derive(Debug, Clone)]\n   pub struct MaintenanceTask {\n       pub name: String,\n       pub sql: String,\n       pub priority: MaintenancePriority,\n       pub estimated_duration_secs: u64,\n   }\n   \n   impl DbMaintenance {\n       pub fn new() -> Self {\n           Self {\n               maintenance_tasks: vec![\n                   MaintenanceTask {\n                       name: \"VACUUM\".to_string(),\n                       sql: \"VACUUM\".to_string(),\n                       priority: MaintenancePriority::High,\n                       estimated_duration_secs: 60,\n                   },\n                   MaintenanceTask {\n                       name: \"ANALYZE\".to_string(),\n                       sql: \"ANALYZE\".to_string(),\n                       priority: MaintenancePriority::Medium,\n                       estimated_duration_secs: 30,\n                   },\n                   // Outras tarefas...\n               ],\n               schedule: MaintenanceSchedule::Daily { hour: 3, minute: 30 },\n           }\n       }\n       \n       pub async fn start_scheduled_maintenance(self, pool: DbPool) {\n           tokio::spawn(async move {\n               loop {\n                   let sleep_duration = self.calculate_next_run();\n                   tokio::time::sleep(sleep_duration).await;\n                   self.perform_maintenance(&pool).await;\n               }\n           });\n       }\n       \n       async fn perform_maintenance(&self, pool: &DbPool) {\n           // Implementa√ß√£o para executar tarefas de manuten√ß√£o\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  },
  {
    "id": 280,
    "title": "Backup autom√°tico",
    "description": "- Implementar rotina de backup:",
    "priority": "alta",
    "category": "Db",
    "code_example": "pub struct DbBackupManager {\n       backup_dir: PathBuf,\n       retention_days: u32,\n       schedule: BackupSchedule,\n   }\n   \n   #[derive(Debug, Clone)]\n   pub enum BackupSchedule {\n       Hourly,\n       Daily { hour: u8, minute: u8 },\n       Weekly { day: u8, hour: u8, minute: u8 },\n   }\n   \n   impl DbBackupManager {\n       pub fn new<P: AsRef<Path>>(\n           backup_dir: P,\n           retention_days: u32,\n           schedule: BackupSchedule,\n       ) -> Self {\n           Self {\n               backup_dir: backup_dir.as_ref().to_path_buf(),\n               retention_days,\n               schedule,\n           }\n       }\n       \n       pub async fn start_scheduled_backups(self, db_path: String) {\n           tokio::spawn(async move {\n               loop {\n                   let sleep_duration = self.calculate_next_run();\n                   tokio::time::sleep(sleep_duration).await;\n                   self.perform_backup(&db_path).await;\n                   self.cleanup_old_backups().await;\n               }\n           });\n       }\n       \n       async fn perform_backup(&self, db_path: &str) -> Result<PathBuf, ApiError> {\n           // Implementa√ß√£o para criar backup do banco\n       }\n       \n       async fn cleanup_old_backups(&self) -> Result<usize, ApiError> {\n           // Implementa√ß√£o para remover backups antigos\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db",
      "backup"
    ],
    "context": "Db"
  },
  {
    "id": 281,
    "title": "Conex√µes com tempo de vida",
    "description": "- Renovar conex√µes periodicamente:",
    "priority": "baixa",
    "category": "Db",
    "code_example": "pub struct DbConnectionManager {\n       pool: DbPool,\n       connection_ttl: Duration,\n   }\n   \n   impl DbConnectionManager {\n       pub fn new(pool: DbPool, connection_ttl_hours: u64) -> Self {\n           Self {\n               pool,\n               connection_ttl: Duration::hours(connection_ttl_hours as i64),\n           }\n       }\n       \n       pub async fn start_connection_renewal(self: Arc<Self>) {\n           tokio::spawn(async move {\n               loop {\n                   tokio::time::sleep(std::time::Duration::from_secs(3600)).await; // A cada hora\n                   self.renew_connections().await;\n               }\n           });\n       }\n       \n       async fn renew_connections(&self) -> Result<usize, ApiError> {\n           // Implementa√ß√£o para renovar conex√µes antigas\n       }\n   }",
    "status": "pendente",
    "tags": [
      "db"
    ],
    "context": "Db"
  }
]